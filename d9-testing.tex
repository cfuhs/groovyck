
\section{Software testing}
\label{sec:software-testing}

I know your code has bugs. If it is a small project it will have few
bugs. If it is a big projects it has a lot of bugs. I know.

How do I know? Because I know you are a human being, and human beings
make mistakes. When a programmer is writing a program, there are too
many things to keep in the short-term memory at the same time: data
structures, communication between different parts of the program,
flows of information\ldots Any program except the most trivial one is
too complex for the human mind to see in its entirety. This is why we
need to use methods to isolate operations that are executed often and
why we use classes to group different functionalities of our program
around some conceptual ideas that we can grasp (e.g.~a supermarket has
queues, a queue has people, a person has a name and knows who is
behind in the queue; a company has products and employees, employees
have names and take money from the company, products give money to the
company). 

Structured and object-oriented programming are ways in which
programmers can reduce the complexity of their programs to levels that
are more or less manageable, but it is still impossible to write
programs that do not contain bugs. Humans, even the best programmers,
have a tendency to forget some details of the program. That is the way
the human mind works: it concentrates on the bug fundamental aspect
and forgets the details until needed\ldots which in computing means
when the program is already executing and nothing can be done about
it. 

Long story short, as long as programming is performed by humans,
programs will have bugs. The compiler can make sure that a program is
syntactically correct but it cannot tell if  it makes sense or
even whether it will do what the programmer expects. 

That is why software testing is important. Testing a program is a way
to ensure that the program does what it should. There are two types of
testing: manual and automatic (Table~\ref{tab:test}). You are already
familiar with the former type, you have been doing it for weeks with
the programs you have been writing until now. Now we will learn how to
do things properly in an automated way. 

\begin{table}[htbp]
  \centering
  \begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
    \hline
    & Manual & Automatic \\
    \hline
    Speed & Very slow & Very fast \\
    Focus & Most important bugs known & All bugs known \\
    Experience & Very repetitive and boring & The computer does the work \\
    Thouroughness & Sometimes forgets to test some things & Tests everything always \\
    \hline
  \end{tabular}
  \caption{Manual testing vs automated testing}
  \label{tab:test}
\end{table}


The idea behind automated testing is very simple: make a program that
tests that your ``main'' program behaves as expected. You can execute
this ``testing'' program every day as you original program grows to
make sure that everything works as it
should. Figures~\ref{fig:sdfsdsers} and~\ref{fig:sdfsdsers} provide
two examples from real life when program did not behave as expected. 

\begin{figure}[tbp]
\begin{verbatim}
    Programmer 1: The program has messed-up and not we have lost data
        from our clients!
    Programmer 2: How is that possible?
    Programmer 1: The function returnPastPurchases() returned null,
        the system got a NullPointerException and crashed. 
    Programmer 2: Oh! It returned null because there were no past
        purchases. 
    Programmer 1: But it has always returned an empty array! 
    Programmer 2: But I thought that null was more elegant than an
        empty array. If there is nothing to return, why not return
        null? 
    Programmer 1: What about... because the rest of the program
        expects an empty array! Now we face our clients sueing us!
    Programmer 2: I am sorry...
\end{verbatim}  
  \caption{Scenario 1: unmet expectations}
  \label{fig:sdfsdsers}
\end{figure}

\begin{figure}[tbp]
\begin{verbatim}
    Programmer 1: Good, now we have found the bug. Method 
        getTaxReturns() had problems when it received a null
        TaxPayer. We have fixed the method that was returning 
        a null TaxPayer. Let's create a test for it to make sure it
        does not happen again. 
    Programmer 2: No need to. It will never happen again. I will never
        forget this week working 20h a day! I promise you no method
        will return a null TaxPayer ever again. 
    (...one year later...)
    Programmer 1: There is a serious bug in the system!
    Programmer 2: I have found it! Someone returned a null TaxPayer. 
    Programmer 1: What? A year ago, you promised me that it was not
        going to happen again!
    Programmer 2: It is not my fault! Someone else must have made
        changes to the core classes!
\end{verbatim}  
  \caption{Scenario 2: Star Bugs: Return of the Bug}
  \label{fig:sdfsdsers}
\end{figure}

Programs can behave badly for an infinite number of reasons,
including: 

\begin{itemize}
\item bad programmers writing bad code.
\item lack of communication between programmers in a big project.
\item programs without documentation that have to be modified, usually
  by a programmer that has nothing to do with the original
  programmers.
\item version changes in external libraries (or even the programming
  language) that not backwards-compatible.
\item changes in some part of the program affecting some other part of
  the program, apparently unrelated. 
\end{itemize}

The last reason is particularly important because it is the most
common and it is quite difficult to fight. Big programs are usually
written by many programmers, and none of them know everything about
the code. Sometimes a change in some part of the code breaks something
else that had been working until then. The problem becomes worse as
programmers leave the project and other programmers join in with no
previous knowledge about the program. 
This results in programs that
are more and more difficult to modify and adapt as they evolve over
time. This is know as \emph{code viscosity}, and it is bad. Automated
testing, by means of regression tests, is a way of fighting code
viscosity: when the computer tests that everything that has been
working until then ---even many parts that the programmer is now aware
of--- is still working, the programmer knows that the last change did
not brake anything. 

\subsection{Automated testing}
\label{sec:automated-testing}

How do you write your own tests for your Java programs? You write them
as Java programs, using a special library called JUnit. There are
other ways, but JUnit is very simple, powerful, and well-known. JUnit
does not come with Java by default, but you can easily install it from
the web as it is free software\footnote{\emph{Free} as in free speech,
not free beer.}. 

An automated test is just a collection of methods that will be
executed by JUnit. These methods will test the methods in your
``main'' classes, and check that they return the right values. If they
do not, for any reason, JUnit will raise a flag so that you can look
into your code and find out why it is not behaving as expected. 

Let's see an example. Imagine that we have 
a method that returns the initials of a name
in a class called \verb+Person+: 

\begin{verbatim}
    public String getInitials(String fullName)
     {
        String result = "";
        String[] words = fullName.split(" ");
        for (int i = 0; i < words.length; i++)
          {
             String nextInitial = "" + words[i].charAt(0);
             result = result + nextInitial.toUpperCase();
          }
        return result;
     }
\end{verbatim}

A test program would be a Java class that could look like this: 

\begin{verbatim}
    import org.junit.*;
    import static org.junit.Assert.*;
    
    public class PersonTest {    
       @Test
       public void testsNormalName() {
            Person p = new Person();
            String input = "Dereck Robert Yssirt";
            String output = p.getInitials(input);
            String expectedOutput = "DRY";
            assertEquals(output, expectedOutput);
         }
    }
\end{verbatim}

As you can see, there are several things that make a test class (using
JUnit) different from a normal Java class. First of all, there is no
main method. JUnit tests are not executed directly, they are executed
by JUnit, so there is no need for a main method. 

A second important difference are those \verb+import+ statements are
the beginning, before the class definition. These importing statements
are the way in which a programmer can tell Java to use classes that
are not in the current folder (they must be in the \emph{classpath},
though). If you want to import just some static methods from some
class, you can use \emph{static imports}. In this example, the method
\verb+assertEquals(String,String)+ is statically imported from class
\verb+Assert+. This is only a convenience so that you do not need to
write \verb+Assert.assertEquals(....)+, only the method's name is
enough. 

The third difference is the most important one. There is a special
kind of word before the method definition, a word starting with an at
symbol: \verb+@Test+. These \@-words are called \emph{annotations} in
Java, and have a special meaning for the compiler. For example, the
annotation \verb+@Test+ tells JUnit that the method
\verb+testsNormalName()+ is a test to be run by JUnit. This is the way
JUnit know which methods to run and which methods to ignore. (We will
learn more about annotations in the future).

You can also appreciate some conventions in the code. The test class
for class \verb+Person+ is called \verb+PersonTest+ (some people
prefer \verb+TestPerson+). And the method's name tells the story of
the test. It can be read as ``this method'' \verb+testsNormalName()+:
this method tests a normal name.


How to design your tests


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
