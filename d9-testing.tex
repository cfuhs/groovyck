
\section{Software testing}
\label{sec:software-testing}

I know your code has bugs. If it is a small project it will have few
bugs. If it is a big projects it has a lot of bugs. I know.

How do I know? Because I know you are a human being, and human beings
make mistakes. When a programmer is writing a program, there are too
many things to keep in the short-term memory at the same time: data
structures, communication between different parts of the program,
flows of information\ldots Any program except the most trivial one is
too complex for the human mind to see in its entirety. This is why we
need to use methods to isolate operations that are executed often and
why we use classes to group different functionalities of our program
around some conceptual ideas that we can grasp (e.g.~a supermarket has
queues, a queue has people, a person has a name and knows who is
behind in the queue; a company has products and employees, employees
have names and take money from the company, products give money to the
company). 

Structured and object-oriented programming are ways in which
programmers can reduce the complexity of their programs to levels that
are more or less manageable, but it is still impossible to write
programs that do not contain bugs. Humans, even the best programmers,
have a tendency to forget some details of the program. That is the way
the human mind works: it concentrates on the bug fundamental aspect
and forgets the details until needed\ldots which in computing means
when the program is already executing and nothing can be done about
it. 

Long story short, as long as programming is performed by humans,
programs will have bugs. The compiler can make sure that a program is
syntactically correct but it cannot tell if  it makes sense or
even whether it will do what the programmer expects. 

That is why software testing is important. Testing a program is a way
to ensure that the program does what it should. There are two types of
testing: manual and automatic (Table~\ref{tab:test}). You are already
familiar with the former type, you have been doing it for weeks with
the programs you have been writing until now. Now we will learn how to
do things properly in an automated way. 

\begin{table}[htbp]
  \centering
  \begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
    \hline
    & Manual & Automatic \\
    \hline
    Speed & Very slow & Very fast \\
    Focus & Most important bugs known & All bugs known \\
    Experience & Very repetitive and boring & The computer does the work \\
    Thouroughness & Sometimes forgets to test some things & Tests everything always \\
    \hline
  \end{tabular}
  \caption{Manual testing vs automated testing}
  \label{tab:test}
\end{table}


The idea behind automated testing is very simple: make a program that
tests that your ``main'' program behaves as expected. You can execute
this ``testing'' program every day as you original program grows to
make sure that everything works as it
should. Figures~\ref{fig:sdfsdsers} and~\ref{fig:sdfsdsers} provide
two examples from real life when program did not behave as expected. 

\begin{figure}[tbp]
\begin{verbatim}
    Programmer 1: The program has messed-up and not we have lost data
        from our clients!
    Programmer 2: How is that possible?
    Programmer 1: The function returnPastPurchases() returned null,
        the system got a NullPointerException and crashed. 
    Programmer 2: Oh! It returned null because there were no past
        purchases. 
    Programmer 1: But it has always returned an empty array! 
    Programmer 2: But I thought that null was more elegant than an
        empty array. If there is nothing to return, why not return
        null? 
    Programmer 1: What about... because the rest of the program
        expects an empty array! Now we face our clients sueing us!
    Programmer 2: I am sorry...
\end{verbatim}  
  \caption{Scenario 1: unmet expectations}
  \label{fig:sdfsdsers}
\end{figure}

\begin{figure}[tbp]
\begin{verbatim}
    Programmer 1: Good, now we have found the bug. Method 
        getTaxReturns() had problems when it received a null
        TaxPayer. We have fixed the method that was returning 
        a null TaxPayer. Let's create a test for it to make sure it
        does not happen again. 
    Programmer 2: No need to. It will never happen again. I will never
        forget this week working 20h a day! I promise you no method
        will return a null TaxPayer ever again. 
    (...one year later...)
    Programmer 1: There is a serious bug in the system!
    Programmer 2: I have found it! Someone returned a null TaxPayer. 
    Programmer 1: What? A year ago, you promised me that it was not
        going to happen again!
    Programmer 2: It is not my fault! Someone else must have made
        changes to the core classes!
\end{verbatim}  
  \caption{Scenario 2: Star Bugs: Return of the Bug}
  \label{fig:sdfsdsers}
\end{figure}

Programs can behave badly for an infinite number of reasons,
including: 

\begin{itemize}
\item bad programmers writing bad code.
\item lack of communication between programmers in a big project.
\item programs without documentation that have to be modified, usually
  by a programmer that has nothing to do with the original
  programmers.
\item version changes in external libraries (or even the programming
  language) that not backwards-compatible.
\item changes in some part of the program affecting some other part of
  the program, apparently unrelated. 
\end{itemize}

The last reason is particularly important because it is the most
common and it is quite difficult to fight. 

Regression tests
Code Viscosity


\subsection{Automated testing}
\label{sec:automated-testing}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
