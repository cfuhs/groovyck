\section{Introduction}

%Simple input/output with integers, outputting words and ends of lines, assignment and initialisation}

To get a computer to do something, you have to tell it what you want it
to do.  You give it a series of instructions in the form of a \emph{program}.
You write a program in a \emph{programming language}.
Many programming languages have been devised; well known ones include
Fortran, BASIC, Cobol, Algol, Lisp, Ada, C++, Python, Ruby, Scala, and Java.

Programming languages vary a lot, but
an instruction in a typical programming language might contain
some English words (such as \verb!while! or \verb!return!), perhaps a mathematical
expression (such as \verb!x + 2!) and some punctuation marks used in a special way.
The following three lines are in BASIC, Cobol and C++ respectively:
\begin{Verbatim}
      FOR I% = 1 TO 100 STEP 5 DO

      PERFORM RECORD-TRANSACTION UNTIL ALL-DONE = "T"

      if (x > 100) cout << "Big"; else cout <<; "Small";
\end{Verbatim}

Programs can vary in length from a few lines to thousands of lines.
Here is a complete, short program written in Groovy:

\VerbatimInput[frame=single,label=Example]{src/Example1.groovy}

When you write a program, you have to be very careful to keep to the
syntax, i.e., to the rules of the language.  For example, the above program would
behave incorrectly if we wrote 

\begin{Verbatim}
	if (max = 0)
\end{Verbatim}

instead of 

\begin{Verbatim}
	if (max == 0)
\end{Verbatim}

or if we put a semi-colon immediately after 

\begin{Verbatim}
      if (s.length() > max)
\end{Verbatim}

The computer would refuse to accept it if we added semi-colons in strange places
or if any of the parentheses (or curly braces) were missing, or if we wrote
\verb!leng! instead of \verb!length()! or even \verb!Length()! instead of \verb!length()!.

The language we will use in this document is named \emph{Groovy}, and
it is very similar to the Java programming language but with a
simplified syntax. 

\subsection{Input and output}

To get the computer to take some input and to store it
in its memory, we write, for example\footnote{Pay attention to the brackets
and the capital letters.}):

\begin{Verbatim}
      str = System.console().readLine()
\end{Verbatim}

\verb!System.console().readLine()! (pronounced \emph{system dot
  console dot read line}) is a phrase which has a special meaning to
the computer. The combination of these instructions
means\footnote{Strictly speaking, it means ``Take the current system
  ---this computer---, take its console ---its keyboard and screen---,
and read a line from it as introduced by the user'' (from the keyboard,
not the screen because the user cannot type a line on the screen... or
could not before they invented touchscreens!)).} ``Take
some input, a sequence of characters, and put it into the memory.''

\verb!str! by contrast, is a word that I (the programmer) have chosen.
I could have used \verb!characters! or \verb!thingy! or \verb!foodle!
or just \verb!s! or almost any word I wanted. (There are some
restrictions which I will deal with in the next section.)  You may
occasionally see the semi-colon used in a program and that signals the
end of this instruction.

Computers can take in all sorts of things as input --- numbers,
letters, words, records and so on --- but, to begin with, we will
write programs that generally handle strings of characters (like
"I", "hi", "My mother has 3 cats", or "This is AWESOME!").
We'll also assume that the computer is taking its input from the
keyboard, i.e., when the program is executed, you key in one or more
words at the keyboard and these are the characters that it puts into
its memory.

You can imagine the memory of the computer as consisting of lots of
little boxes.  Programmers can reserve some of these boxes for
use by their programs and they refer to these boxes by giving
them names.  

\begin{Verbatim}
      str = System.console().readLine()
\end{Verbatim}

means "Take a string of characters until the user presses RETURN and
then put it in the box called \verb!str!."  When the program runs and
this instruction gets executed, the computer will take the words which
you type at the keyboard (whatever you like) and will put them into
the box which has the (temporary) name of \verb!str.!

Each of these boxes can hold only one string at a time.  If a box is
holding, say, "hello", and you put a "Good bye!" into it, the
"Good bye!" replaces the "hello".  In computer parlance these
boxes are called \emph{variables} because the content inside the box
can vary; you can put a "I" in it to start with and later change it
to a "you" and change it again to "That was a hurricane" and so on
as often as you want.

In Groovy you have to tell the computer that you want to use a variable
with a certain name before you use it.  You can't just pitch in using \verb!str!
without telling it what \verb!str! is.  Most of the time you also have to
tell it what type of variable it is, i.e., what sort of thing you are going
to put into it.  In this case we are going to put strings of characters into it.
Strings of characters, or simply \emph{strings} as they are called in programming, are
known in Groovy as \verb!String!, with capital S.  To tell the computer that we want to use a
variable of type \verb!String! called \verb!str!, we write

\begin{Verbatim}
      String str;
\end{Verbatim}

If we wanted more than one variable, we could use two lines:

\begin{Verbatim}
      String myName
      String yourName
\end{Verbatim}

or we could declare them both on one line, separated by a comma
\begin{Verbatim}
      String myName, yourName
\end{Verbatim}

Your program can have as many variables as you want.  In Groovy you don't
have to declare all your variables at the start of the program, as is the
case in some other languages.  You can declare them in the middle of a
program, but you mustn't try to use a variable before you've declared it.

If you want the computer to display (on the screen) the contents of one of
its boxes, you use \verb!print! followed by the name
of the box.  For example

\begin{Verbatim}
      print str
\end{Verbatim}

If the contents of the box called \verb!str! happened to be "Karl" when the
computer came to execute \verb!print str! then the word "Karl" would appear
on the screen.  

% Arithmetic expressions such as \verb!num + 5! can also appear in a \verb!print!
% line.  For example, if \verb!num! had the value 7, then \verb!print num + 5!
% would output 12.
If we use \verb!println! instead of \verb!print! then an extra line is
printed after the value. 

So we can now write a program in Groovy (not a very exciting program,
but it's a start):

\VerbatimInput[frame=single,label=Example]{src/Example2.groovy}

This program takes some text as input from the keyboard and displays it
on the screen.

It is customary to lay out programs like this with each part on a line 
of its own. The indentation, if there is any, is just for the benefit
of human readers, not for the computer.

\subsection{Compiling and running a program}

You can learn the rudiments of Groovy from these notes just by doing the
exercises with pencil and paper.  It is not essential to run your programs
on a computer.  However, if you have a computer and are wondering how
you run the programs, you will need to know the following, and, even if you don't have
a computer, it will help if you have some idea of how it's done.

First of all you type your program into the computer using a text
editor. Then, 
before you can run the program, you have to \emph{compile} it.  This means that
you pass it through a piece
of software called a \emph{compiler}.  The compiler checks whether your program
is acceptable according to the syntax of Groovy.  If it isn't, the compiler
issues one or more error messages telling you, in a more or less unhelpful
fashion, what it objects to in your program and where the problem lies.
You try to see what the problem is, correct it and try again.  You keep
doing this until the program compiles successfully.  You now have an
executable version of your program, i.e., your program has been translated
into the internal machine instructions of the computer and the computer
can run your program.

Now you issue a command (or click on an icon) and the computer executes
your program.  If you are lucky, your program does what it is supposed
to do first time.  Often it doesn't.  You look at what your program is
doing, look again at your program and try to see why it is not doing what
you intended.  You correct the program, recompile and run it again.
You might have to do this many times before the program behaves in the way
you wanted.

As I said earlier, you can study this introduction without running your
programs on a computer.  However, it's possible that you have a PC with
a Groovy compiler and will try to run some of the programs given in these
notes. 
If you have a PC but you don't have a compiler, I attach a few notes telling
you how you can obtain one (see Section~\ref{sec:obta-inst-runn} on
page~\pageref{sec:obta-inst-runn}).

\subsection{Outputting words and ends of lines}

Let's suppose that you managed to compile your program in one way or
another and that you then ran it.  Your running of the above program
would produce something like this on the screen:

\begin{Verbatim}
Tom
Tom
\end{Verbatim}

The first line is the result of you keying in a word.  The system "echoes"
the keystrokes to the screen, in the usual way.  When you hit RETURN, the
computer executes the \verb!str = System.console().readLine()! line, 
i.e., it reads the word or words.  Then it
executes the \verb!println! line and the sentence appears on the screen again.

We can also get the computer to display additional words by putting
them in quotes after the \verb!println!, for example:

\begin{Verbatim}
      println "Hello"
\end{Verbatim}

We can use this to improve the above program:

\VerbatimInput[frame=single,label=Example]{src/Example3.groovy}

A run of this program might appear on the screen thus:
\begin{Verbatim}
Please key in a word: Tom
The word was: Tom
\end{Verbatim}

Note the spaces in the \verb!print! lines after \verb!word:! and \verb!was:!.
This is so that what appears on the screen is \verb!word: Tom! and
\verb!was: Tom! rather than \verb!word:Tom! and \verb!was:Tom!.

It's possible to output more than one item with a single \verb!print! line.
For example, we could combine the last two lines of the program into one:

\begin{Verbatim}
println "The word was " + str
\end{Verbatim}

and the output would be exactly the same. The symbol "+" does not
represent addition, only concatenation: writing one string after the
other. We will see addition of numbers in the next section.

Let's suppose that we now added three lines to the end of our program, thus:

\VerbatimInput[frame=single,label=Example]{src/Example4.groovy}

The screen would look something like this:
\begin{Verbatim}
Please key in a word: Tom
The word was TomNow please key in another: Jack
And this one was Jack
\end{Verbatim}

Which is probably not what we wanted.  If we want a new line after the
output of the first word, we have to use the \verb!println! instruction we mentioned earlier:

\VerbatimInput[frame=single,label=Example]{src/Example5.groovy}

Now we would get:
\begin{Verbatim}
Please key in a word: Thomas
The word was Thomas
Now please key in another: Jackie
And this one was Jackie
\end{Verbatim}


\subsection*{Exercise A}

Now pause and see if you can write
\begin{enumerate}
\item
a line of Groovy which would output a blank line.
\item
a line of  which would output

\begin{Verbatim}
Hickory, Dickory, Dock
\end{Verbatim}

\item
a program which reads in two words, one after the other, and then displays them
in reverse order. If the input was 

\begin{Verbatim}
First
Second
\end{Verbatim}

the output should be

\begin{Verbatim}
Second
First
\end{Verbatim}

\end{enumerate}

%To check your answers, click on  \verb!Answers to the exercises!. (TO BE COMPLETED)

\subsection{Assignment and initialisation}

There is another way to get a string into a box apart from using
\verb!System.console().readLine()!.  We can write, for instance:

\begin{Verbatim}
str = "Some text"
\end{Verbatim}

This has the effect of putting the string "Some text" into the
\verb!str! box.  Whatever was in \verb!str! before is obliterated; the
new text replaces the old one. 

In programming, this is called \emph{assignment}.  We say that the
value "Some text" is
assigned to the variable \verb!str!, or that the variable \verb!str! takes the
value "Some text".  The "=" symbol is the assignment operator in Groovy.  We are not
testing whether \verb!str! has the value "Some text" or not, nor are we stating that
\verb!str! has the value "Some text"; we are \emph{giving} the value
"Some text" to \verb!str!.

% Unneeded. Probably should delete.
%
% If we want, we can have arithmetic expressions on the right-hand side of
% the "=", for example:
% \begin{Verbatim}
% num = count + 10
% \end{Verbatim}
% This instruction means, "Take whatever number is in \verb!count!,
% add 10 to it and put the result into \verb!num!."

An assignment instruction such as this:

\begin{Verbatim}
    str = str + " and some more"
\end{Verbatim}

looks a little strange at first but makes perfectly good sense.
Let's suppose the current value of \verb!str! (the contents of the
box) is "Some text".
The instruction says, "Take the value of \verb!str!
("Some text"), add " and some more"  to it ("Some text and some
more") 
and put the result into \verb!str!".
So the effect is to put "Some text and some more" into \verb!str! in
place of the earlier "Some text".

The \verb!=! operator is also used to initialise variables.  When the computer
allocates a portion of memory to store one of your variables, it does not
clear it for you; the variable holds whatever value this portion of memory
happened to have the last time it was used.  Its value is said to be
\emph{undefined.}

Using undefined values is a common cause of program
bugs.  % Suppose a program uses the variable \verb!str! without giving it an
% initial value and suppose that, on the computer the programmer is using,
% the initial value in \verb!num! happens to be zero and that, by happy chance,
% zero is just what the programmer wants it to be.
% The program seems to work fine.  Then the program is compiled and run on
% a different computer.  On this second computer, the initial value of \verb!num!
% does not happen to be zero.  The program, which has worked OK on the first
% computer, does not work on the second one.
%
To prevent yourself from using undefined values, you can give a variable
an initial value when you declare it.  If you wanted \verb!str! to begin
with empty, you should declare it thus:

\begin{Verbatim}
      String str = "";
\end{Verbatim}

This is very like assignment since we are giving a value to \verb!str! but
this is a special case where \verb!str! did not have any defined value before,
so it is known as \emph{initialisation.}

Finally a word about terminology.  I have used the word "instruction"
to refer to lines such as \verb!println str! and \verb!str = 5!
It seems a natural word to use since we are giving the computer instructions.
But the correct word is actually "statement".  \verb!println str! is
an output statement, and \verb!str = "Hello"! is an assignment statement.
The lines in which we tell the computer about the variables we intend to
use, such as \verb!String str! or \verb!String str = ""! are called
variable \emph{definitions}.  They are also referred to as 
variable \emph{declarations}.  When you learn more about Groovy you will
find that you can have declarations which are not definitions, but the
ones in these introductory notes are both definitions and declarations.

\subsection*{Exercise B}

Now see if you can write a program in Groovy that takes
two words from the keyboard and outputs one after the other. E.g., if
you keyed in "Humpty" and "Dumpty" 
it would reply with "Humpty Dumpty" (note the space in between).
A run of the program should look like this:
\begin{Verbatim}
Please key in a word: Humpty
And now key in another: Dumpty
You have typed: Humpty Dumpty
\end{Verbatim}

%To check your answers, click on \verb!Answers to the exercises!. (TO BE COMPLETED)

 	

%%% Local Variables:
%%% TeX-master: "primer"
%%% End:
