
\section{Testing and Mock Objects}
\label{sec:testing-mock-objects}

In a real project, especially if you are following the Test-Driven
Development (TDD) methodology, sometimes you have to test your class
as it interacts with classes that do not exist yet. Maybe you have a
\verb+Wheel+ class that needs to talk to 
an \verb+AntiblockBrakingSystem+ class, but
you have not implemented the latter yet. In a real scenario
(e.g.~initial stages of a new project), a class may interact with tens
of other classes which have not been implemented yet. How can you test
it?

% TODO: this example sucks; replace it with something from real life,
%   or at least a good example that does not rely of ugly methods like
%   getLastRotation() and getLastRotationOrder()

\begin{verbatim}
    @Test
    public void 
        Wheel wheel = new Wheel();
        AntiblockBrakingSystem abs = new FpgaAntiblockBrakingSystem();
        double input = abs.getRotation(wheel);
        wheel.rotate(input);
        assertEquals(wheel.getLastRotation(), input);
    }
\end{verbatim}

If Wheel must communicate with AntiblockBrakingSystem and the latter
(or its implementations if it is an interface) does not exist, how can
it work?.

The answer is to use \emph{mock objects} (sometimes called dummy
objects or dummies). A mock object is a trivially simple object that
implements an interface to allow other objects to be tested. In other
words, it fakes the real functionality that is needed to test another
class. By using mock objects, as they say, you can fake until you make
it. 

In the former testing method we can see that
objects of type \verb+Wheel+ needs to talk to an object of type
\verb+AntiblockBrakingSystem+ that implement one methods:
\verb+getRotation(Wheel)+. 
We can
easily create a trivial class that implements that in five lines: 

\begin{verbatim}
public class MockAbs implements AntiblockBrakingSystem {
    public double getRotation(Wheel wheel) {
        return 0.12345;
    }
}
\end{verbatim}

As you can see, a mock class (and the mock objects that you obtain
every time you use \verb+new+ with it) is trivially simple. There are
neither complex algorithms nor deep data structures in a mock object:
just the bare minimum needed to test other classes. A mock object (an
object of type \verb+MockAbs+ in this case) will
contain as many methods as the interface it implements
(one, in the case of \verb+AntiblockBrakingSystem+), but not more. 

Remember that testing methods should be independent from each other,
and that is why we do some building-up and some cleaning-up before and
after each of them (in methods marked with \verb+@Before+ and
\verb+@After+). In the same way, testing classes should be independent
and not rely on each other. Mock objects help you achieve that goal. 
By isolating a class from the others (using interfaces and mock
objects) you can ensure that the bugs in one class are not propagated
to other classes making their tests fail for obscure and mysterious
reasons. 

Using mock objects, our original test would look like: 

\begin{verbatim}
    @Test
    public void 
        Wheel wheel = new Wheel();
        AntiblockBrakingSystem abs = new MockAbs();
        double input = abs.getRotation(wheel);
        wheel.rotate(input);
        assertEquals(wheel.getLastRotation(), input);
    }
\end{verbatim}

It is exactly the same code but using a mock object. Now we can be
sure that any bug in \verb+FpgaAntiblockBrakingSystem+ will not
propagate into this test and break it, appearing as an error in the
method \verb+rotate(double)+ (in diagnosis terms, a false positive).
