
\section{Constants}
\label{sec:constants}

Programs use data, lots of data. Data is stored in variables of simple
and complex types (the latter being pointers that point to objects in
the memory, in the heap). We have used a lot of variables since we
started our journey into programming. 

Sometimes, we know that a piece of data is not going to change. 
Maybe it is a physical constant like the
speed of light, maybe it is a mathematical constant like $\pi$, or
maybe it something else. Any such piece of data in your program, that
is known to not change, is called a \emph{constant}. 

You do not want your program to allow any section
of the code to modify your constants, even by mistake. This is achieved by
using the keyword \verb+final+. This keyword tells Java that the value
of a variable must never change from the moment it is initialised
until the program ends. See an example: 

\begin{verbatim}
    public static final double PI = 3.14159265359; 
\end{verbatim}

By convention, constants are written all in capital
letters. Multi-word constants use underscores, as in: 

\begin{verbatim}
    public static final int SPEED_OF_LIGHT = 299792458;
\end{verbatim}

% Cross-refs
You remember that we said that static \emph{fields} should be used
sparingly, and mostly (or only) for constants. The keyword
\verb+final+ is used to declare an identifier as constant, and
therefore both keywords (\verb+static+ and \verb+final+)
are frequently found together when applied to constants: final ensures
the value cannot be changed while static ensures there is only one
field (a ``box'') for the whole class rather than one duplication in
every object of the class.

You may also remember that we mentioned that constant fields can be
made public, as there is no risk of anyone modifying their values
producing some undesirable side effect. If you ever make a field public in a
class that has methods, make sure you make it static and (especially)
final.

\begin{center}
{\large \textbf{If a field is public, it must be static and final.}}  
\end{center}

The only exception to this rule is for classes without
methods. Remember that such a class can be used as a way of
interchanging several pieces of data bundled together (as a return
value, for example). 

% TODO: next year, make a bigger point of how final for a complex
% types means just a constant pointer, not a constant object. 

\section{Documenting your code with JavaDoc}
\label{sec:docum-your-code}

% TODO: write this better

We have already seen how the Java library is completely documented
online. All classes are described on a web page that explains
what they are and what they do (i.e.~their
methods, explaining the parameters), and this information is online on
the Java API documenation or JavaDoc. You can find the JavaDoc easily
by typing ``Java API'' on your favourite search engine. 

The good news is that it is easy to document your own classes in the
same professional way as the core Java library. In order to do so, we
just need to write the comments of our code in a special way and then
use the program \verb+javadoc+. 

\subsection{How to write comments}
\label{sec:writing-comments}

As we briefly saw when we introduced interfaces, JavaDoc comments
start by \verb+/**+, end by \verb+*/+, and can span several
lines. JavaDoc comments can also tag additional information regarding
parameters or return values, as shown in the following example: 

\begin{verbatim}
    /**
     * An StringStack is a dynamic structure that can contain any number
     * of strings. 
     * 
     * New elements (i.e. Strings) can be put on top of the stack or
     * removed from the top of the stack. Only the element at the top of
     * the stack can be removed at any given time; to access a specific 
     * element, all elements on top of it must be removed (popped) first. 
     * 
     * This interface allows the user to replace some elements of the list
     * even if they are not accessible. 
     */
    public interface StringStack {
        /**
         * Put an element at the top of the stack. 
         *
         * @param newString the new string to be put
         */
        void push(String newString);
        /**
         * Removes the element at the top of the stack and returns it. 
         *
         * @return the element at the top of the stack
         */
        String pop();
        /**
         * Replaces every occurrence of one string in the stack
         * for another string. 
         *
         * @param oldString the string to be replaced
         * @param newString the new string to replace it with
         */
        void push(String oldString, String newString);
    }
\end{verbatim}

There are three important things to notice in this example: 

\begin{itemize}
\item All comments start with \verb+/**+ and end with \verb+*/+. It is
  customary to make each line in the comment start with a star too.
\item Parameters are documented with the tag \verb+@param+, followed
  by the name of the parameter, followed by the description.
\item Return values are documented with the tag \verb+@return+,
  followed by the description of what is returned. 
\end{itemize}

Comments should explain the functionality of your classes and methods
in a short and clear way. Comments should not explain the internal
implementation details unless it really makes a difference to other
programmers using those classes or methods. In other words, comments
should be as clear as possible, and as short as possible, in that
order of importance\footnote{The Java documentation itself is a good
  inspiration of what good comments should look like. Use it as an
  inspiration as well as a source of information.}. 

\subsection{How to create the online documentation}
\label{sec:how-create-online}

Creating the webpages with the documentation of your classes and
methods is very simple. Assumming that you have all your classes
documented (i.e.~with proper comments) in a folder called \verb+src+
and want to put all the web pages in a folder called \verb+www+, you
just need to run the following command: 

\begin{verbatim}
    > javadoc path/to/src/*java -d path/to/www/
\end{verbatim}

This will generate all the web pages, HTML files, CSS style sheets,
links, etc, for you on the \verb+www+ folder. The folder will contain
a file called \verb+index.html+ as a starting point. 

\section{More on testing}
\label{sec:more-testing}

\subsection{Additional annotations}
\label{sec:addit-annot}

In the former section we have seen how basic testing is performed. A
testing method is marked with the annotation \verb+@Test+, and this
indicates to JUnit that the method will be run as a test. The testing
method contains one (sometimes more) \emph{assertions}, which is
nothing more than a call to one of the methods of class
\verb+org.junit.Assert+, like \verb+assertTrue(...)+ 
and \verb+assertEquals(...,...)+. 

In this section we are going to learn how to create slightly more
complicated tests. 

\subsubsection*{Constraints: timeout and expected}
\label{sec:timeout}

Sometimes a bug does not result in an incorrect return value,
sometimes it results in an infinite loop or an extremely long response
time. If we want to specify a maximum time for our testing methods to
run, we can do it by passing a ``timeout'' parameter to annotation
\verb+@Test+, as in the following example: 

\begin{verbatim}
    @Test(timeout = 1000)  
    public void testsThatFinishedBeforeOneSecond() {  
        // ...
    }  
\end{verbatim}

If the method does not return a value before 1000 milliseconds have
passed, the test will fail. 

We can also expect a method to return an exception, as in the
following example: 

\begin{verbatim}
    @Test(expected = IndexOutOfBoundsException.class)
    public void testsNegativeIndecesFail() {  
        // ...
    }  
\end{verbatim}

If the method does not throw an \verb+IndexOutOfBoundsException+ in
this test, the test will fail. Note that this is quite the contrary of
the usual behaviour: when a testing method throws an exception, it is
usually a symptom of something not working as expected; but this not
always the case. Situations in which we may want to expect an exception
include requests to lists beyond their size, parsing strings that
are not in the right format, and passing negative parameters to
methods that only accept positive integers. 

\subsubsection*{Initialisation: Before and After}
\label{sec:init-before-after}

Testing methods usually require the creation of some object. It is
quite common that this is needed for all testing method in a testing
class. 

Instead of repeating the same code in each and every method, which
is boring and error-prone, we can create a method to do that before
every testing method is called. This method must be annotated with
\verb+@Before+. In the same way, if some cleanup must be performed
after each testing method ends and before the next testing method
starts, this should be marked with the \verb+@After+ annotation. See
the example: 

\begin{verbatim}
    @Before
    public void buildUp() {  
        // A file is created here to be used in every test. 
    }  
    @After
    public void cleanUp() {  
        // The file is deleted here, after each test ends
    }  
\end{verbatim}

Assuming that your testing class contains three testing methods, the
execution path would be: buildUp, first test, cleanUp, buildUp, second
test, cleanUp, buildUp, third test, cleanUp. Note that you can change
the names of the methods (buildUp and cleanUp are common choices).

\subsubsection{Heavy initialisation: BeforeClass and AfterClass}
\label{sec:heavy-init-befor}

Using \verb+@Before+ and \verb+After+ is appropriate in those cases in
which initialisation and clean-up are fast. However, if the resources
needed are costly to allocate and release, and if they are not changed
inside each testing method, then it is better to just do some
initialisation at the beginning of all tests and some clean-up at the
end of all test. 

This is done by using the annotations \verb+@BeforeClass+ and
\verb+@AfterClass+. Examples of resources that are typically acquired and
released once per class include network connections and database
connections. 


\subsection{Test-Driven Development}
\label{sec:test-driv-devel}

Test-Driven Development (TDD) is a programming methodology that advocates
that tests should be driven before the actual program. This is
radically different from writing the program first and then writing
the tests as we have done in the past.

The TDD methodology consists of three steps that are repeated in a
loop: 

\begin{enumerate}
\item Write the tests for the next functionality/feature of the program. Make
  sure they fail. If they do not fail, that means they are not testing
  anything that was not tested before (and are redundant) or they are
  incorrect (and should be fixed). 
\item Write the minimal code that passes all the new tests.
\item Refactor the code to make it clearer and simpler. Run the tests
  at the end to make sure the final functionality is right. 
\end{enumerate}

There are four main benefits for this style of programming:

\begin{itemize}
\item As the tests are written in advance, the \emph{production} code
  is written in a way that is easy to test.
\item As the tests are written in advance, all the code is tested by
  at least one testing method. Otherwise, programmers can forget to
  test some methods.
\item Writing the tests first makes the programmers think about the
  real specification of the class or method, focusing on \emph{what}
  needs to be done before their short-term memory is filled with
  \emph{how} to do it.
\item Errors are detected early, when they are cheap to fix. It is
  more difficult for bug to remain undetected until later in the
  development, when it can be more costly to fix them.
\end{itemize}

The mains shortcoming is that it is difficult to see any progress at
the beginning of the project. Time is spent writing tests and nothing
``tangible'' can be shown to managers or clients. But the effort pays
in the long run, when the code evolves in a controlled way, with a
strong battery of tests that ensures that bugs do not re-appear and
that the functionality is always moving forward. 

The TDD methodology can be combined with the ``find bugs once'' strategy
we already know. A program can be developed using TDD, finding most
bugs in the process, but some bugs may appear later in the development
cycle; if that happens, the ``find bugs once'' strategy results in
adding new tests that will find them as soon as they reappear.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
