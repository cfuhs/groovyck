\documentclass{article}
\usepackage[margin=2cm]{geometry}
\usepackage[dvips]{graphicx}
\begin{document}

\section*{Learning goals}
\label{sec:learning-goals}

Before the next day, you should have achieved the following learning
goals: 

\begin{itemize}
\item Be able to write recursive for simple problems
\item Understand what a recursive method looks like, and how it
  differs from an iterative method. 
\end{itemize}

Remember that \textbf{exercises marked with a star (*) are harder and take
longer to solve}, so you should not try them until you have solved all
the non-star ones. 

\section{Recursive code, line by line}
\label{sec:read-recurs-code}

\subsection*{a)}

What number would the following method print on screen if you called
\verb+printNumbers(6)+?

\begin{verbatim}
    void printNumbers(int n) {
        if (n <= 0) {
            return;
        }
        printLine(n);
        printNumbers(n-2);
        printNumbers(n-3);
        printLine(n);
    }
\end{verbatim}

Do this exercise on paper. Then add this method to a Java Decaf
program and check your answer. 

\subsection*{b)}
\label{sec:b-1}

Do you see anything wrong with the following code? How would you fix it?

\begin{verbatim}
    String buggyMethod(int n) {
        if (n == 0) {
            return "";
        }
        return n + " " + buggyMethod(n - 2);
    }
\end{verbatim}

\subsection*{c)}
\label{sec:b-3}

Do you see anything wrong with the following code? How would you fix it?

\begin{verbatim}
    String doggyMethod(int n) {
        String result = doggyMethod(n-3) + n + doggyMethod(n-2);
        if (n <= 0) {
            return "";
        }
        return result;
    }
\end{verbatim}

\subsection*{d) McCarthy's 91 function}
\label{sec:c}

Calculate the result of calling this method with arguments 50, 73, 
and~95. Note that the recursion on line 5 is double. 

\begin{verbatim}
    int mcCarthy91(int n) {
        if (n > 100) {
            return n - 10;
        } else {
           return mcCarthy91(mcCarthy91(n+11));
        }
    }
\end{verbatim}

(Hint: If you get too confused, maybe writing a slightly modified
version of this code that prints the numbers on screen can help).

\section{Classics}

\subsection{a) Factorial }

Write a small program with a method that calculates the factorial of an
integer number as seen in the notes. 

Is it easy to do this both iteratively and recursively? Try both ways
and see which is more natural for you. If one takes too long, try the
other way. 

\subsection{b) Fibonacci }

Write a small program with a method that calculates the n$^{th}$ element
of the Fibonacci sequence as seen in the notes.

Is it easy to do this both iteratively and recursively? Try both ways
and see which is more natural for you. If one takes too long, try the
other way. 

When doing it recursively, do it with and without memoization. Compare
the time that is needed in each case to find F(40) or F(45). 

\subsection{c) Hanoi towers}

A legend says that, somewhere in the East, near Hanoi, there is a
temple. In the temple, there are three posts. In the posts, there are
64 discs of 64 different sizes. When the world was created, all the
discs were in the first post; when all the discs are moved to the
last post, the world will end. 

The monks in the temple move the discs between posts, but they must
obey two simple rules. First, only one disc can be moved at a time,
from one post to another post (it cannot be left anywhere else). Last,
but not least, a disc can only be placed on top of a bigger disc, never
on top of a smaller disc. The smallest disc can be placed
on any post (all other discs are bigger); the biggest disc can only be
placed on an empty post.

Create a method that calculates the number of moves necessary to move
a set of $n$ Hanoi disks from the initial post to the last post. 
\textbf{Hint:}
if you want to play monk yourself in order to better understand the
problem, ask the lecturer for a ``Hanoi envelope''. 

\section{Paper sizes (*)}
\label{sec:paper-sizes}

A Din-A0 sheet of paper is 841mm $\times$ 1189mm (its surface is one
square meter). Successive measurements of paper are defined
recursively as ``half'' or ``double'' the preceding size. Therefore,
a Din-A1 sheet of paper is half of Din-A0, or 594mm $\times$ 841mm;
while a Din-A00 is double of Din-A0, or 1189mm$\times$ 1682mm. 

Create a method that takes a String parameter representing a size
(e.g.~''A4'', ``A00000'') and prints on screen the size of the
corresponding sheet of paper. For simplicity, you can ignore rounding
errors when calculating smaller sizes. 

Hint: note that two consecutive sizes always share one side and only
the other one is multiplied or divided by two, e.g. the \emph{short}
side of~Din-A2 is as long as the \emph{long} side of~Din-A3, while the
long side of~Din-A2 is twice as long as the short side of~Din-A3.

\section{Palindrome}
\label{sec:palindrome}

Create a program with a (recursive) method that takes a String
paremeter and
returns true if the String is a palindrome and false
otherwise. Compare this recursive version with the iterative version
you wrote in past weeks. Which one seems clearer to you?

\section{Power}
\label{sec:power}

Create a class with a method \verb+pow+ that takes two integers
(\verb+base+ and \verb+exponent+) and calculates the power, 
e.g.~\verb+pow(2,3)+ calculates $2^3$. 

Is it easy to do this both iteratively and recursively? 

\section{Hanoi Redux (**)}
\label{sec:hanoi-redux}

The legend of the Towers of Hanoi has inspired countless variations as
mind games. Here is one of them: if we have three posts and 64 discs,
where all the even-numbered discs are on the leftmost post while the
odd-numbered discs are on the rightmost post, how many moves do we
need to exchange the discs following the Hanoi rules for disc
movement? 

Write a method that calculates the number of moves necessary to
exchange $n$ discs. 

\section{How big is your stack? (*)}
\label{sec:how-big-your}

Write a method that calculates the maximum size of the stack (measured
in method calls) by forcing a \verb+StackOverflowError+. Use different
version of your method, each of them with a different number and
different types of local variables, and see
how the number of maximum function calls changes depending on that. 

% Exercises
%   - Greatest common divisor ( p > q => gcd(p,q) = gcd(q, p % q) )
%   - Koch star?
%   - merge sort
%   - Finding longest common subsequence
%   - Root finding for a polynomial (one between -1000 and 1000 if
%       sign(f(min)) != sign(f(max)) , as many as possible for **)
%   - Memoization: Fibonacci numbers
%   - 8 dames on a chess board
%   - Increments and unfolding
%   - Dominoes
%   - How big is your stack? 


\end{document}