\section{Introduction}

%Simple input/output with integers, outputting words and ends of lines, assignment and initialisation}

To get a computer to do something, you have to tell it what you want it
to do.  You give it a series of instructions in the form of a \emph{program}.
You write a program in a \emph{programming language}.
Many programming languages have been devised; well known ones include
Fortran, BASIC, Cobol, Algol, Lisp, Ada, C++, Python, Ruby, Scala, and Java.

Programming languages vary a lot, but
an instruction in a typical programming language might contain
some English words (such as \verb!while! or \verb!return!), perhaps a mathematical
expression (such as \verb!x + 2!) and some punctuation marks used in a special way.
The following three lines are in BASIC, Cobol and C++ respectively:
\begin{Verbatim}
	FOR I% = 1 TO 100 STEP 5 DO

	PERFORM RECORD-TRANSACTION UNTIL ALL-DONE = "T"

	if (x > 100) cout << "Big"; else cout <<; "Small";
\end{Verbatim}

Programs can vary in length from a few lines to thousands of lines.
Here is a complete, short program written in Groovy:

\VerbatimInput[frame=single,label=Example]{src/Example1.groovy}

When you write a program, you have to be very careful to keep to the
syntax, i.e., to the rules of the language.  For example, the above program would
behave incorrectly if we wrote 
\begin{Verbatim}
	if (max = 0)
\end{Verbatim}
instead of 
\begin{Verbatim}
	if (max == 0)
\end{Verbatim}
or if we put a semi-colon immediately after 
\begin{Verbatim}
while (sc.hasNext())
\end{Verbatim}
The computer would refuse to accept it if we added semi-colons in strange places
or if any of the parentheses (or curly braces) were missing, or if we wrote
\verb!leng! instead of \verb!length()! or even \verb!Length()! instead of \verb!length()!.

The language we will use in this document is named \emph{Groovy}, and it is very similar to the Java programming language but with a simplified syntax.

\subsection{Input and output}

To get the computer to take some input and to store it
in its memory, we write, for example:
\begin{Verbatim}
str = sc.next()
\end{Verbatim}
where \verb!sc! represents the input device that we setup with 
\begin{Verbatim}
	Scanner sc = new Scanner(System.in)
\end{Verbatim}
\verb!System.in! (pronounced System dot in) is a phrase which has a special meaning to the
computer.  The combination of these two instructions means "Take some input, a sequence of characters, and put it into the memory."
\verb!str! by contrast, is a word that I (the programmer) have chosen.  I could
have used \verb!characters! or \verb!thingy! or \verb!foodle! or just \verb!s! or almost
any word I wanted. (There are some restrictions which I will deal with in the next section.)
You may occasionally see the semi-colon used in a program and that signals the end of this instruction.

Computers can take in all sorts of things as input --- numbers, letters, words,
records and so on --- but, to begin with, we will write programs that
only handle numbers (whole numbers like 0, 2, 15, 10025, -1, -2465).
We'll also assume that the computer is taking its input from the keyboard,
i.e., when the program is executed, you key in one or more numbers at the
keyboard and these are the numbers that it puts into its memory.

You can imagine the memory of the computer as consisting of lots of
little boxes.  Programmers can reserve some of these boxes for
use by their programs and they refer to these boxes by giving
them names.  
\begin{Verbatim}
	num = sc.nextInt()
\end{Verbatim}
means "Take a number and put it in the
box called \verb!num!."  When the program runs and this instruction gets
executed, the computer will take a number which you type at the keyboard
(8 or -25 or 9999 or whatever you like) and will put it into the box which
has the (temporary) name of \verb!num.!

Each of these boxes can hold only one number at a time.  If a box is
holding, say, 26, and you put a 44 into it, the 44 replaces the 26.
In computer parlance these boxes are called \emph{variables}
because the number inside the box can vary; you can put a 10 in it to
start with and later change it to a 20 and change it again to 555
and so on as often as you want.

In Groovy you have to tell the computer that you want to use a variable
with a certain name before you use it.  You can't just pitch in using \verb!num!
without telling it what \verb!num! is.  Most of the time you also have to
tell it what type of variable it is, i.e., what sort of thing you are going
to put into it.  In this case we are going to put whole numbers into it.
Whole numbers, or \emph{integers} as they are called in programming, are
known in Groovy as \verb!int!.  To tell the computer that we want to use a
variable of type \verb!int! called \verb!num!, we write
\begin{Verbatim}
int num
\end{Verbatim}
If we wanted more than one variable, we could use two lines:
\begin{Verbatim}
int num
int total
\end{Verbatim}
or we could declare them both on one line, separated by a comma
\begin{Verbatim}
int num, total
\end{Verbatim}
Your program can have as many variables as you want.  In Groovy you don't
have to declare all your variables at the start of the program, as is the
case in some other languages.  You can declare them in the middle of a
program, but you mustn't try to use a variable before you've declared it.

If you want the computer to display (on the screen) the contents of one of
its boxes, you use \verb!print! followed by the name
of the box.  For example
\begin{Verbatim}
print num
\end{Verbatim}
If the contents of the box called \verb!num! happened to be 876 when the
computer came to execute \verb!print num! then the number 876 would appear
on the screen.  

Arithmetic expressions such as \verb!num + 5! can also appear in a \verb!print!
line.  For example, if \verb!num! had the value 7, then \verb!print num + 5!
would output 12.
If we use \verb!println! instead of \verb!print! then an extra line is printed after the value.

So we can now write a program in Groovy (not a very exciting program,
but it's a start):

\VerbatimInput[frame=single,label=Example]{src/Example2.groovy}

This program takes a number as input from the keyboard and displays it
on the screen.

It is customary to lay out programs like this with each part on a line
of its own. The indentation, if there is any, is just for the benefit of human readers, not for the computer.

\subsection{Compiling and running a program}

You can learn the rudiments of Groovy from these notes just by doing the
exercises with pencil and paper.  It is not essential to run your programs
on a computer.  However, if you have a computer and are wondering how
you run the programs, you will need to know the following, and, even if you don't have
a computer, it will help if you have some idea of how it's done.

First of all you type your program into the computer using a text editor, but
before you can run the program you have to \emph{compile} it.  This means that
you pass it through a piece
of software called a \emph{compiler}.  The compiler checks whether your program
is acceptable according to the syntax of Groovy.  If it isn't, the compiler
issues one or more error messages telling you, in a more or less unhelpful
fashion, what it objects to in your program and where the problem lies.
You try to see what the problem is, correct it and try again.  You keep
doing this until the program compiles successfully.  You now have an
executable version of your program, i.e., your program has been translated
into the internal machine instructions of the computer and the computer
can run your program.

Now you issue a command (or click on an icon) and the computer executes
your program.  If you are lucky, your program does what it is supposed
to do first time.  Often it doesn't.  You look at what your program is
doing, look again at your program and try to see why it is not doing what
you intended.  You correct the program, recompile and run it again.
You might have to do this many times before the program behaves in the way
you wanted.

As I said earlier, you can study this introduction without running your
programs on a computer.  However, it's possible that you have a PC with
a Groovy compiler and will try to run some of the programs given in these
notes. 
If you have a PC but you don't have a compiler, I attach a few notes telling
you how you can obtain one.

\subsection{Outputting words and ends of lines}

Let's suppose that you managed to compile your program in one way or
another and that you then ran it.  Your running of the above program
would produce something like this on the screen:
\begin{Verbatim}
1234
1234
\end{Verbatim}
The first line is the result of you keying in a number.  The system "echoes"
the keystrokes to the screen, in the usual way.  When you hit RETURN, the
computer executes the \verb!sc.nextInt()! line, i.e., it reads the number.  Then it
executes the \verb!println! line and the number appears on the screen again.

We can also get the computer to display words by putting them in quotes
after the \verb!println!, for example:
\begin{Verbatim}
	println "Hello"
\end{Verbatim}
We can use this to improve the above program:

\VerbatimInput[frame=single,label=Example]{src/Example3.groovy}

A run of this program might appear on the screen thus:
\begin{Verbatim}
Please key in a number: 34
The number was 34
\end{Verbatim}
Note the spaces in the \verb!print! lines after \verb!number:! and \verb!was!.
This is so that what appears on the screen is \verb!number: 34! and
\verb!was 34! rather than \verb!number:34! and \verb!was34!.

It's possible to output more than one item with a single \verb!print! line.
For example, we could combine the last two lines of the program into one:
\begin{Verbatim}
println "The number was " + num
\end{Verbatim}
and the output would be exactly the same.

Let's suppose that we now added three lines to the end of our program, thus:

\VerbatimInput[frame=single,label=Example]{src/Example4.groovy}

The screen would look something like this:
\begin{Verbatim}
Please key in a number: 34
The number was 34Now please key in another: 56
And this one was 56
\end{Verbatim}
Which is probably not what we wanted.  If we want a new line after the
output of the first number, we have to use the \verb!println! instruction we mentioned earlier:

\VerbatimInput[frame=single,label=Example]{src/Example5.groovy}

Now we would get:
\begin{Verbatim}
Please key in a number: 9876
The number was 9876
Now please key in another: 543
And this one was 543
\end{Verbatim}
We can input two or more numbers but we will need to use multiple \verb!sc.nextInt()! instructions.  The numbers can
be on the same line, separated by one or more spaces, or on separate lines.
The following lines:

\VerbatimInput[frame=single,label=Example]{src/Example6.groovy}

would read 5 into \verb!x! and 6 into \verb!y! in any of the following ways:
\begin{Verbatim}
Please key in two numbers: 5 6
\end{Verbatim}
or
\begin{Verbatim}
Please key in two numbers: 
5
6
\end{Verbatim}
or
\begin{Verbatim}
Please key in two numbers: 5
6
\end{Verbatim}

\subsection{Exercise 1A}

Now pause and see if you can write
\begin{enumerate}
\item
a line of Groovy which would output a blank line.
\item
a line of  which would output
\begin{Verbatim}
Hickory, Dickory, Dock
\end{Verbatim}
\item
a program which reads in two integers on one line and displays them
in reverse order.  If the input was \verb!3 99!, the output should be
\verb!99 3!.
\end{enumerate}

To check your answers, click on  \verb!Answers to the exercises!. (TO BE COMPLETED)

\subsection{Assignment and initialisation}

There is another way to get a number into a box apart from using
\verb!nextInt()!.  We can write, for instance:
\begin{Verbatim}
num = 22
\end{Verbatim}
This has the effect of putting the number 22 into the \verb!num! box.  Whatever
was in \verb!num! before is obliterated; the new number replaces the old one.

In programming, this is called \emph{assignment}.  We say that the value 22 is
assigned to the variable \verb!num!, or that the variable \verb!num! takes the
value 22.  The "=" symbol is the assignment operator in Groovy.  We are not
testing whether \verb!num! has the value 22 or not, nor are we stating that
\verb!num! has the value 22; we are \emph{giving} the value 22 to \verb!num!.

If we want, we can have arithmetic expressions on the right-hand side of
the "=", for example:
\begin{Verbatim}
num = count + 10
\end{Verbatim}
This instruction means, "Take whatever number is in \verb!count!,
add 10 to it and put the result into \verb!num!."

An assignment instruction such as this:
\begin{Verbatim}
num = num + 5
\end{Verbatim}
looks a little strange at first but makes perfectly good sense.
Let's suppose the current value of \verb!num! (the contents of the box) is 14.
The instruction says, "Take the value of \verb!num!
(14), add 5 to it (19) and put the result into \verb!num.!"
So the effect is to put 19 into \verb!num! in place of the earlier 14.

The \verb!=! operator is also used to initialise variables.  When the computer
allocates a portion of memory to store one of your variables, it does not
clear it for you; the variable holds whatever value this portion of memory
happened to have the last time it was used.  Its value is said to be
\emph{undefined.}

Using undefined values is a common cause of program
bugs.  Suppose a program uses the variable \verb!num! without giving it an
initial value and suppose that, on the computer the programmer is using,
the initial value in \verb!num! happens to be zero and that, by happy chance,
zero is just what the programmer wants it to be.
The program seems to work fine.  Then the program is compiled and run on
a different computer.  On this second computer, the initial value of \verb!num!
does not happen to be zero.  The program, which has worked OK on the first
computer, does not work on the second one.

To prevent yourself from using undefined values, you can give a variable
an initial value when you declare it.  If you wanted \verb!num! to begin
with the value zero, you should declare it thus:
\begin{Verbatim}
int num = 0
\end{Verbatim}
This is very like assignment since we are giving a value to \verb!num! but
this is a special case where \verb!num! did not have any defined value before,
so it is known as \emph{initialisation.}

Finally a word about terminology.  I have used the word "instruction"
to refer to lines such as \verb!println num! and \verb!num = 5!
It seems a natural word to use since we are giving the computer instructions.
But the correct word is actually "statement".  \verb!println num! is
an output statement, and \verb!num = 5! is an assignment statement.
The lines in which we tell the computer about the variables we intend to
use, such as \verb!int num! or \verb!int num = 0! are called variable \emph{definitions}.  They are also referred to as
variable \emph{declarations}.  When you learn more about Groovy you will
find that you can have declarations which are not definitions, but the
ones in these introductory notes are both definitions and declarations.

\subsection{Exercise 1B}

Now see if you can write a program in Groovy that takes
two numbers from the keyboard and outputs their sum. E.g., if you keyed in 6 and 8
it would reply with 14.  A run of the program should look like this:
\begin{Verbatim}
Please key in a number: 6
And now key in another: 8
The sum is 14
\end{Verbatim}
To check your answers, click on \verb!Answers to the exercises!. (TO BE COMPLETED)

