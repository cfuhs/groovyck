
\section{Exception handling}
\label{sec:exception-handling}

If you try to parse as an integer something that is not an integer
number, you get a \verb+NumberFormatException+. If you try to call the
object of an object but the object is \verb+null+, you get a
\verb+NullPointerException+. But what are exceptions? And is there a
way to handle them so that they do not always crash a program? 

Exceptions represent exceptional circumstances that should never occur
in the normal (some would say \emph{ideal}) execution of a
program. When one of these exceptional circumstances ---like trying to
follow a \verb+null+ pointer--- happens, the Java Virtual Machine
throws an exception to indicate it. 

An exception interrupts the normal execution of the method where it
happened. It breaks the method where it was happening and moves up to
the calling method, where it may be caught. If it is not caught in the
calling method, it will go up again, and again, until it is caught. If
it is not caught, not even in the original \verb+main+ method, it will
be caught by the Java Virtual Machine and it will be printed on the
standard output as you have seen several times already. 

\begin{verbatim}
    Exception in thread "main" java.lang.NullPointerException
      at LinkedListNode.addNode(LinkedListNode.java:49)
      at LinkedList.addNode(LinkedList.java:30)
	at HospitalManager.launch(HospitalManager.java:71)
	at HospitalManager.main(HospitalManager.java:13)
\end{verbatim}

\subsubsection*{Reading a stack trace}

An exception contains information about the state of the Java Virtual
Machine when it was thrown. In particular, it contains the whole stack
of methods calls. This is very useful because it helps programmers to
find what went wrong (and maybe why). 

The most useful line of the stack trace is usually the first one,
because it says exactly where the exceptional situation happened. For
example, in the stack trace above we can observe that a
\verb+NullPointerException+ was thrown at line 49 of the code of class 
\verb+LinkedListNode+. With this information a programmer can look at
that specific line and try to understand why a null pointer was
accessed when this should not happen. 

If we want more information we just need to follow the stack trace
line by line. We can see that the program started at the main method
of class \verb+HospitalManager+, that the \verb+launch()+ method was
called on like 13, and that this method called the method
\verb+addNode()+ in class \verb+LinkedList+ (on line 71), which in
turn called the method \verb+addNode()+ of class \verb+LinkedListNode+
(on line 30), where the exception was thrown. 

There is no limit to the length of a stack trace. Then can have as
many steps as the size of your stack, which is several thousands of
calls deep (depending on the number of local variables per method
call). 

Sometimes the stack trace goes into code that has not been written by
us, as in the following example (comments ommitted for brevity): 

\begin{verbatim}
01    public class ExceptionThrower {
02       public static void main(String[] args) {
03          ExceptionThrower et = new ExceptionThrower();
04          et.launch();
05       }
06       private void launch() {
07          System.out.print("Write a number: ");
08          int n = getNumber();
09          String evenness = (n % 2 == 0) ? "even" : "odd";
10          System.out.println("You entered " + n + ", an " + evenness + " number."$
11       }
12       private int getNumber() {
13          String str = System.console().readLine();
14          int result = Integer.parseInt(str);
15          return result;
16       }
17    }
\end{verbatim}

If you enter numbers like 2 or 19, all will work well. However, if you
enter something like ``three'' you will get a detailed stack trace to
blame you for your incompetence typing integer numbers: 

\begin{verbatim}
    Exception in thread "main" java.lang.NumberFormatException: For input string: "three"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
	at java.lang.Integer.parseInt(Integer.java:449)
	at java.lang.Integer.parseInt(Integer.java:499)
	at ExceptionThrower.getNumber(ExceptionThrower.java:14)
	at ExceptionThrower.launch(ExceptionThrower.java:8)
	at ExceptionThrower.main(ExceptionThrower.java:4)
\end{verbatim}

We can see that the program started in the \verb+main+ method, that is called
the method \verb+launch()+, that this method called the method
\verb+getNumber()+, and then this method called
\verb+Integer.parseInt()+. From that point on, the stack trace shows
method calls happening inside classes of the basic Java Library, like
\verb+Integer+ and \verb+NumberFormatException+, but you can see that
the information is exactly the same: method calls and line numbers. If
you have access to the source code of those external classes, you will
see the line numbers and will be able to trace the stack of method
calls in detail. If you work with external libraries from which you do
not have the source code, you will only see the names of the methods
but not the line number. 

The example allows us to observer the ``interrupting'' nature of
exceptions. The \verb+NumberFormatException+ interrupted the execution
of method \verb+getNumber()+ (line 15 was not executed), then
interrupted the caller method \verb+launch()+ (lines 09--10 were never
executed), and then interrupted the \verb+main+ method. Since the
exception was never \emph{caught}, it went all the way up to the
\verb+main+ method and then was shown by the Java Virtual Machine. 

\subsection{Catching exceptions}
\label{sec:catching-exception}

Exceptions are handles by using try/catch constructs: you ``try'' some
code where exceptions may be thrown; if exceptions are thrown, you
``catch'' them and do something about them. See the following example: 

\begin{verbatim}
12    private int getNumber() {
13       int result = 0; // default
14       try { 
15          String str = System.console().readLine();
16          result = Integer.parseInt(str);
17          System.out.println("You entered " + result + ".");
18       } catch (NumberFormatException ex) {
19          System.out.println("You entered something that is not an integer number.");
20       }
21       return result;
22    }
\end{verbatim}

If a \verb+NumberFormatException+ is thrown at line 16, the normal
execution of the method is interrupted. Program execution jumps out of
the current \verb+try+ clause (i.e.~until the next closing curly
bracket). It is caught there ---there is a \verb+catch+ statement for
that type of exception---, and the code inside the \verb+catch+ clause is 
executed. Then the execution proceeds normally. 

If the exception jump up to the end of the scope and is not caught, it
will jump up to the end of the next scope. If it is still not caught,
it will jump up to the end of the next scope and so on. This usually
means that the exception is moving up the method stack from calling
method to calling method until it is caught. If it is never caught, it
will crash your program and appear on screen. 

In a way, you can think
of this as a huge \verb+catch+ statement just out of your main method
that only prints the stack trace.

\begin{verbatim}
    // WARNING: this is only a metaphore, not real code
    try {
        mainMethod();
    } catch (AnyException ex) {
        ex.printStackTrace().
    }
\end{verbatim}

The method \verb+printStackTrace()+ is very useful, and is almost
always used in \verb+catch+ statements because it really helps in
debugging your program when a exception is thrown in an unexpected
place. The method prints the name of every single method that had been
called when the exception was thrown, including the line that was
being executed (if the source code for the class is known). 

A \verb+try+ clause can have many \verb+catch+ clauses associated to
it, as in the following example: 

\begin{verbatim}
12    private int getNumber() {
13       int result = 0; // default
14       try {
15           System.out.print("Enter a number with at least 3 digits: ");
16           String str = System.console().readLine();
17           result = Integer.parseInt(str);
18           System.out.println("You entered " + result + ".");
19           char thirdDigit = str.charAt(2);
20           System.out.println("The third digit is " + thirdDigit + ".");
21       } catch (NumberFormatException ex) {
22           System.out.println("ERROR 1: You entered something that is not an $
23       } catch (IndexOutOfBoundsException ex) {
24           System.out.println("ERROR 2: You entered integer with less than 3 $
25       }
26       return result;
27     }
\end{verbatim}

If a \verb+NumberFormatException+ is thrown on line~17, the execution
of the program will jump to line~21, where it will be caught. After
that \verb+catch+ clause is executed, the program will continue at the
end of the try/catch construct at line~26. If a
\verb+IndexOutOfBoundsException+ is thrown at line~19, the execution
of the program will jump to line~21, and then to line~23, where it
will be caught. After that \verb+catch+ clause is executed, the
program will continue at the end of the try/catch construct at line~26.  

A \verb+try+ clause can also have a \verb+finally+ clause, which can
used for cleaning up resources. We will see more of this when we learn
about input/output. 

\subsection{Which methods throw exceptions?}
\label{sec:which-methods-throw}



%   Example...

% How to handle them
%   try/catch constructs
%   finally -> left for files?

% Checked exception and unchecked (runtime) exceptions
%   checked must be caught 
%     or declared as thrown (so that somebody else catches them)

% The danger of "disappearing" exceptions. 

Once an exception is caught, it does not go ``up'' anymore. It
disappears. 

% How to throw an exception

% How to create a new exception
%   Re-throw an exception
%   Should all new exceptions be runtime exceptions? 

% Other throwables: Errors

% Final note: comparison with error-checking

% Exercises: 
%  - Sequence flow with or without exception
%  - Read numbers. If not a number, show error message and start
%    again.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "d15"
%%% End:
