\section{Inheritance}
\label{sec:inheritance-1}

Repeating code is a bad thing. When the same code is used in more than
one place in a program, it is a disaster waiting to happen. Sooner or
later, one of the copies of the code will be changed (probably to fix
a bug), but not all copies will be changed\ldots and unpredictable things
will happen (never good). 

We already know how to use methods in a class to avoid repetition of
code inside the class. When the code is inside a method, the
programmer can just call the method from different areas of the code
and the same instructions will be always executed (probably with
different values for the parameters). In this section, we will move
one step further to avoid code repetition by using \emph{inheritance} to
prevent code repetitions \emph{among} classes. 

\section{Extending already-existing classes}
\label{sec:extend-alre-exist}

From all the forms of inheritance, the easiest to understand is the
extension of already existing classes. This is done by means of the
keyword \verb+extends+. 

Let's assume that we had a class \verb+Ebook+,
part of a program to run an electronic book reader. The class would
several methods, including some like \verb+nextPage()+,
\verb+prevPage()+, and \verb+readAloud(int page)+. When the next
version of our electronic book reader comes out, it includes a new
feature to regulate the background light of the screen. At this point
we have two options. First, we can add a new method
\verb+setLight(int)+ to the \verb+Ebook+ class to regulate the
background light; however, this method would also be part of the
software running in all the non-regulable e-books that we sell from
then on. A second possibility, is to create two different classes,
\verb+Ebook+ and \verb+LightEbook+, each of them used for a different
hardware; but this leads to a lot of methods being repeated, which is
bad. 

There is a third, much better possibility. We can make
\verb+LightBook+ extend \verb+Ebook+ (comments ommited for the sake of
brevity): 

\begin{verbatim}
    public class LighEbook extends Ebook {
        private int lightLevel = 100;
        public void setLight(int newLevel) {
            this.lightLevel = newLevel;
        }
    }
\end{verbatim}

You can see that extending a class is very easy: just say that you are
extending it! Then you will be able to use all the public methods (and
some more, see below on Section~\ref{sec:protected-keyword}) from
the class that you are extending without the need to implement them
again. In other words, you can call \verb+nextPage()+ on a
\verb+LightEbook+ object exactly in the same way as you would do it
on a \verb+Ebook+ object. 


\paragraph{Final classes}
\label{sec:final-classes}

You remember that we could use the keyword \verb+final+ to indicate
that a variable hold a constant value, i.e.~that the variable could
not be changed. In a similar way, we can use it to tell the compiler
that a class cannot be changed either. A class defined as \verb+final+
cannot be extended; trying to do so will result in an error at compile
time. 


\subsection{Top-down inheritance}
\label{sec:top-down-inheritance}

We have already seen that we can use interfaces to specify what a
class is like or, in other words, what is its behaviour: the methods
that are public and can be used by other classes. For example, we may
have an interface \verb+Animal+ that was implemented by classes
\verb+Dog+, \verb+Human+, and \verb+Horse+. The interface may define
methods like \verb+move()+, \verb+makeSound()+, and
\verb+breath()+. The three classes would each implement each method. 

Now, it is quite possible that the implementations of movement and
sounds are quite different, but it is quite possible that methods like
\verb+breath()+ are very similar or the same between the three
classes. As we know, repetition of code is bad: if we have a bug
in the \verb+breath()+ method, we will be in trouble if we forget to
fix it in all classes. It would be much better if we could have the
same method in just one place so that each class could use it, in the
same way that the code in a method can be used from anywhere in the
class. 

It turns out it is quite possible to do this in Java: we can put the
code into the interface\ldots almost. Actually, what we need to do is
to transform the interface into an \emph{abstract class}, and then
make the other classes \emph{extend} it. Assuming
that the original interface looked like this (JavaDoc comments ommited
for the sake of space):

\begin{verbatim}
    public interface Animal {
         void move(int meters);
         String makeSound();
         void breath(int air);
    }
\end{verbatim}

\ldots if we implement the method \verb+breath()+, the resulting
abstract class could look like this: 

\begin{verbatim}
    public abstract class Animal {
         private int oxygen = 0;

         public abstract void move(int meters);
         public abstract String makeSound();
         public void breath(int air) {
             this.oxygen += air / 4;
         }
    }        
\end{verbatim}

As you can see, there are many differences between an interface and an
abstract class: 

\begin{itemize}
\item First and foremost, an interface never contains any actual code,
  while an abstract ---like any other class--- can contain statements
  that perform some action.
\item Interfaces are \emph{implemented}, while abstract classes are
  \emph{extended}.
\item All methods in an interface are by definition public and
  abstract (i.e.~without actual code), so there is no need to write it
  down (but it can be done). On the other hand, methods in an abstract
  class can be private or public, abstract or not, and it must be said
  explicitly for each of them.
\item Abstract classes can contain mutable fields. All fields on an
  interface are by definition static and final (i.e.~constant).
\end{itemize}

There are also some similarities: 

\begin{itemize}
\item Both abstract classes and interfaces can be used as data
  types to declare a variable of a complex type.
\item Neither can be used to instantiate an object using \verb+new+
  (because neither contains a full ``blueprint'' of what the new
  object would look like). 
\end{itemize}

\subsection{Bottom-up inheritance}
\label{sec:boot-up-inher}

%      - bottom-up inheritance: abstract/non-abstract classes

\subsection{Visibility revisited}
\label{sec:protected-keyword}


\subsection{Everything is an object!}
\label{sec:everything-an-object}

%    - everything is Object
%      - equals(), hashcode()

\subsection{Changing (overriding) behaviour}
\label{sec:chang-overr-behav}

%    - overriding / overwriting
%      - annotation @Override
%      - equals(), hashcode()

\subsection{The keyword super}
\label{sec:keyword-super}

%    - super
%      - "hidden" super()

\section{Final note: composition vs. inheritance}
\label{sec:final-note:-comp}

%    \item composition better than extension
