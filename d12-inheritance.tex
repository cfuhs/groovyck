\section{Inheritance}
\label{sec:inheritance-1}

Repeating code is a bad thing. When the same code is used in more than
one place in a program, it is a disaster waiting to happen. Sooner or
later, one of the copies of the code will be changed (probably to fix
a bug), but not all copies will be changed\ldots and unpredictable things
will happen (never good). 

We already know how to use methods in a class to avoid repetition of
code inside the class. When the code is inside a method, the
programmer can just call the method from different areas of the code
and the same instructions will be always executed (probably with
different values for the parameters). In this section, we will move
one step further to avoid code repetition by using \emph{inheritance} to
prevent code repetitions \emph{among} classes. 

\section{Extending already-existing classes}
\label{sec:extend-alre-exist}

From all the forms of inheritance, the easiest to understand is the
extension of already existing classes. This is done by means of the
keyword \verb+extends+. You can think of this keyword as stating a
``is a'' relationship. 

Let's assume that we had a class \verb+Ebook+,
part of a program to run an electronic book reader. The class would
several methods, including some like \verb+nextPage()+,
\verb+prevPage()+, and \verb+readAloud(int page)+. When the next
version of our electronic book reader comes out, it includes a new
feature to regulate the background light of the screen. At this point
we have two options. First, we can add a new method
\verb+setLight(int)+ to the \verb+Ebook+ class to regulate the
background light; however, this method would also be part of the
software running in all the non-regulable e-books that we sell from
then on. A second possibility, is to create two different classes,
\verb+Ebook+ and \verb+LightEbook+, each of them used for a different
hardware; but this leads to a lot of methods being repeated, which is
bad. 

There is a third, much better possibility. We can make
\verb+LightBook+ extend \verb+Ebook+ (comments ommited for the sake of
brevity): 

\begin{verbatim}
    public class LighEbook extends Ebook {
        private int lightLevel = 100;
        public void setLight(int newLevel) {
            this.lightLevel = newLevel;
        }
    }
\end{verbatim}

You can see that extending a class is very easy: just say that you are
extending it! Then you will be able to use all the public methods (and
some more, see below on Section~\ref{sec:protected-keyword}) from
the class that you are extending without the need to implement them
again. In other words, you can call \verb+nextPage()+ on a
\verb+LightEbook+ object exactly in the same way as you would do it
on a \verb+Ebook+ object. 

The base class that is extended is called the \emph{parent class},
while the extending class is called a \emph{subclass}. When there are
many levels of hierarchy (a class extends a class that extends another
class, etc), those classes up in the hierarchy are called
\emph{ancestor classes}, while those down in the hiearchy are called
\emph{descendant classes}. 

\paragraph{Everything is an object!}
\label{sec:everything-an-object}

In Java, every class extends class \verb+Object+ or descends from a
class that extends \verb+Object+. \verb+Object+ is a class from the
core Java library that provides a few methods that every other class
can use. The most commonly used is \verb+equals()+, which compares two
objects and returns \verb+true+ if they are the same (according to
some class-specific rules) and \verb+false+ otherwise. 

\paragraph{Final classes}
\label{sec:final-classes}

You remember that we could use the keyword \verb+final+ to indicate
that a variable hold a constant value, i.e.~that the variable could
not be changed. In a similar way, we can use it to tell the compiler
that a class cannot be changed either. A class defined as \verb+final+
cannot be extended; trying to do so will result in an error at compile
time. 


\subsection{Top-down inheritance}
\label{sec:top-down-inheritance}

We have already seen that we can use interfaces to specify what a
class is like or, in other words, what is its behaviour: the methods
that are public and can be used by other classes. For example, we may
have an interface \verb+Animal+ that was implemented by classes
\verb+Dog+, \verb+Human+, and \verb+Horse+. The interface may define
methods like \verb+move()+, \verb+makeSound()+, and
\verb+breath()+. The three classes would each implement each method. 

Now, it is quite possible that the implementations of movement and
sounds are quite different, but it is quite possible that methods like
\verb+breath()+ are very similar or the same between the three
classes. As we know, repetition of code is bad: if we have a bug
in the \verb+breath()+ method, we will be in trouble if we forget to
fix it in all classes. It would be much better if we could have the
same method in just one place so that each class could use it, in the
same way that the code in a method can be used from anywhere in the
class. 

It turns out it is quite possible to do this in Java: we can put the
code into the interface\ldots almost. Actually, what we need to do is
to transform the interface into an \emph{abstract class}, and then
make the other classes \emph{extend} it. Assuming
that the original interface looked like this (JavaDoc comments ommited
for the sake of space):

\begin{verbatim}
    public interface Animal {
         void move(int meters);
         String makeSound();
         void breath(int air);
    }
\end{verbatim}

\ldots if we implement the method \verb+breath()+, the resulting
abstract class could look like this: 

\begin{verbatim}
    public abstract class Animal {
         private int oxygen = 0;

         public abstract void move(int meters);
         public abstract String makeSound();
         public void breath(int air) {
             this.oxygen += air / 4;
         }
    }        
\end{verbatim}

As you can see, there are many differences between an interface and an
abstract class: 

\begin{itemize}
\item First and foremost, an interface never contains any actual code,
  while an abstract ---like any other class--- can contain statements
  that perform some action.
\item Interfaces are \emph{implemented}, while abstract classes are
  \emph{extended}.
\item All methods in an interface are by definition public and
  abstract (i.e.~without actual code), so there is no need to write it
  down (but it can be done). On the other hand, methods in an abstract
  class can be private or public, abstract or not, and it must be said
  explicitly for each of them.
\item Abstract classes can contain mutable fields. All fields on an
  interface are by definition static and final (i.e.~constant).
\end{itemize}

There are also some similarities: 

\begin{itemize}
\item Both abstract classes and interfaces can be used as data
  types to declare a variable of a complex type.
\item Neither can be used to instantiate an object using \verb+new+
  (because neither contains a full ``blueprint'' of what the new
  object would look like). 
\end{itemize}

\subsection{Bottom-up inheritance}
\label{sec:boot-up-inher}

Sometimes, inheritance is a consequence of the design of your
program: you have an interface that is implemented by several classes
and then decide to add a little code into it and convert it into an
abstract class. 

Sometimes it happens the other way around. Sometimes you have two or
more classes that are apparently unrelated, and then realise that they
have the same code. 

\begin{verbatim}
    public class ManorHouse {
       private Gate gate;
       // ...
       public void closeForTheNight() {
           gate.moveInwards(90);
           gate.getLock().setLocked(true);
       }
       // ...
    }
    (...)
    public class Castle {
       private Gate gate;
       // ...
       public void closeForTheNight() {
           gate.moveInwards(90);
           gate.getLock().setLocked(true);
       }
       // ...
    }       
\end{verbatim}

Code repetition is bad. The method should be put in a parent class: 

\begin{verbatim}
    public abstract class GateGuardedBuilding {
       private Gate gate;
       // ...
       public void closeForTheNight() {
           gate.moveInwards(90);
           gate.getLock().setLocked(true);
       }
    }
    (...)
    public class ManorHouse extends GateGuardedBuilding {
       // ...
    }
    (...)
    public class Castle extends GateGuardedBuilding {
       // ...
    }       
\end{verbatim}

The method \verb+closeForTheNight()+ is available to both
\verb+ManorHouse+ and \verb+Castle+ because they are extending
\verb+GateGuardedBilding+. 

There are situations, though, in which this ``repetition of code'' is not so clear-cut. Look at the
following simplified example:  

\begin{verbatim}
    public class DrinkRefrigerator {
        // ...
        public int buyCan(int money) {
           if (money < price) {
               return money;
           } 
           int change = money - price;
           releaseCan();
           return change;
        }
        // ...
    }
    (...)
    public class ChocBarVendingMachine {
        // ...
        public int getBar(int moneyGiven) {
           if (moneyGiven < price) {
               return moneyGiven;
           } 
           giveChocolateBar();
           int change = moneyGiven - price;
           return change;
        }
        // ...
    }
\end{verbatim}

Although it may not seem at first that a \verb+DrinkRefrigerator+ and
a \verb+ChocBarVendingMachine+ have much in common, an analysis of the
code of methods \verb+buyCan()+ and \verb+getBar()+ shows a strong
similarity, suggesting that the code should be abstracted away to a
parent class. How would it look like? Maybe something similar to this: 

\begin{verbatim}
    public Sale {
        public boolean sold; // public fields because it does not
        public int change;   //    have methods
    }
    (...)
    public abstract class VendingMachine {
        // ...
        public Sale buy(int money, int price) {
           Sale result = new Sale();
           if (money < price) {
               result.sold = false;
               result.change = money;
               return result;
           } else {
               result.sold = true;
               result.change = price - money;
               return result;
           }
        }
        // ...
    }
    (...)
    public class DrinkRefrigerator extends VendingMachine {
        // ...
        public int buyCan(int money) {
           Sale sale = buy(money, price);
           if (sale.sold) {
               releaseCan();
           } 
           return sale.change;
        }
        // ...
    }
    (...)
    public class ChocBarVendingMachine extends VendingMachine {
        // ...
        public int getBar(int money) {
           Sale sale = buy(money, price);
           if (sale.sold) {
               giveChocolateBar();
           }
           return sale.change;
        }
        // ...
    }
\end{verbatim}

The code in the subclasses is shorter and clearer because all the work
is done in the code that was abstracted and put in the parent
class. If this code was more complicated and involved several
comparisons or long intrincated calculations, the benefits would be
even greater. The ``repeated'' methods had two effects: a return value
(change) and a side effect (release can or chocolate bar). Because of
this, we needed to create a new class in order to be able to sort-of
returning two values from the new method. 

\subsection{Visibility revisited}
\label{sec:protected-keyword}



\subsection{Changing (overriding) behaviour}
\label{sec:chang-overr-behav}

%    - overriding / overwriting
%      - annotation @Override
%      - equals(), hashcode()

\subsection{The keyword super}
\label{sec:keyword-super}

%    - super
%      - "hidden" super()

\subsection{The limits of inheritance}
\label{sec:limits-inheritance}

% diamond problems and all

\section{Final note: composition vs. inheritance}
\label{sec:final-note:-comp}

%    \item composition better than extension
