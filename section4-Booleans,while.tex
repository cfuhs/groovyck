\section{Loops and booleans}

How would you write a program to add up a series of numbers?
If you knew that there were, say, four numbers, you might write
this program:

\VerbatimInput[frame=single,label=Example]{src/s3Example.py}

But a similar program to add up 100 numbers would be very long.
More seriously, each program would need to be tailor-made for a particular
number of numbers.  It would be better if we could write one program
to handle \emph{any} series of numbers.  We need a \emph{loop}.

One way to create a loop is to use the keyword \texttt{while}.
For example:

\VerbatimInput[frame=single,label=Example]{src/s3Example2.py}

Similar to the \texttt{if} statement we saw earlier,
it is essential to indent the lines inside the loop.
This allows Python to see which lines are inside the loop and which
lines are ``after'' the loop.
% It is not essential to indent the lines inside the loop, but it makes the
% program easier to read and it is a good habit to get into.


Having initialised the variable \texttt{num} to zero, the program checks
whether the value of \texttt{num} is less than 100.  It is, so it
enters the loop.  Inside the loop, it adds 5 to the value of
\texttt{num} and then outputs this value (so the first thing that
appears on the screen is a \texttt{5}).  Then it goes back to the
  \texttt{while} and checks whether the value of \texttt{num} is less than
100.  The current value of \texttt{num} is 5, which is less than 100,
so it enters the loop again.  It adds 5 to \texttt{num}, so
\texttt{num} takes the value 10, and then outputs this value.  It goes back
to the \texttt{while}, checks whether 10 is less than 100 and enters
the loop again.  It carries on doing this with \texttt{num} getting
larger each time round the loop.  Eventually \texttt{num} has the
value 95. As 95 is still less than 100, it enters the loop again, adds 5 to
\texttt{num} to make it 100 and outputs this number.  Then it goes
back to the \texttt{while} and this time sees that \texttt{num} is not
less than 100.  So it stops looping, goes on to the line after the
end of the loop, and prints `Done looping!'.
The output of this program is the numbers 5,
10, 15, 20 and so on up to 95, 100, followed by `Done looping!'.

Note the use of %curly braces
indent to mark the start and end of the loop.
Each time round the loop the program does everything inside
the indented block.
% the curly braces.
When it decides not to execute the loop again, it jumps to the point
%beyond the closing brace.
beyond the indented block.

What would happen if the \texttt{while} line of this program was
\texttt{while num != 99:}?
The value of \texttt{num} would eventually reach 95.  The computer would
decide that 95 was not equal to 99 and would go round the loop again.
It would add 5 to \texttt{num}, making 100.
It would now decide that 100 was not equal to 99 and would go round the
loop again.  Next time \texttt{num} would have the value 105, then 110,
then 115 and so on.  The value of \texttt{num} would never be equal to 99
and the computer would carry on for ever.  This is an example of
an \emph{infinite loop}.

Note that the computer makes the test \emph{before} it enters the loop.
What would happen if the \texttt{while} line of this program was
\texttt{while num > 0:}?
\texttt{num} begins with the value zero and the computer would first
test whether this value was greater than zero.  Zero is not greater than
zero, so it would not enter the loop.  It would skip straight to the end
of the loop and finish, producing no output.

% It is not essential to indent the lines inside the loop, but it makes the
% program easier to read and it is a good habit to get into.

\subsection*{Exercise A}

Write a program that outputs the squares of all the numbers from 1 to
10, i.e., the output will be the numbers 1, 4, 9, 16 and so on up to 100.

\subsection*{Exercise B}

Write a program that asks the user to type in 5 numbers, and that
outputs the largest of these numbers and the smallest of these
numbers. So, for example, if the user types in the numbers
2456 457  13  999  35, the output will be as follows:

\begin{Verbatim}
    The largest number is 2456
    The smallest number is 13
\end{Verbatim}

\pagebreak

\subsection{Booleans (True/False expressions)}

So far we have just used integer and string values.  But we can
have values of other types and, specifically, we can have
\emph{boolean} values.\footnote{The word ``boolean'' was coined in honour of an
Irish mathematician of the nineteenth century called \emph{George Boole}.}
%In Groovy, these are variables of type \texttt{boolean}.
In Python, this type is called ``bool''. Its values are also called
``truth values'', and they are
%A variable of type \texttt{boolean} does not hold numbers;
%There are only two values for the type bool:
\texttt{True} and \texttt{False}.

\begin{Verbatim}
    positive = True
\end{Verbatim}

Note that we do not have quote marks around the word \texttt{True}.  
The word \texttt{True}, without quote marks, is not a string; it's the name of a
boolean value.  Contrast it with:

\begin{Verbatim}
    positive = 'True'
\end{Verbatim}

Here \texttt{positive} is assigned
the four-character string `\texttt{True}', not the truth value
\texttt{True}. (This is similar to the difference between e.g.\ the
number 42 and the string `42' that we saw earlier.)
%  By contrast, \texttt{positive}
% is a boolean variable and we cannot assign strings to it.
% It can hold only the values \texttt{true} or \texttt{false}.

You have already met boolean expressions.  They are also called conditional
expressions and they are the sort of expression you have
after \texttt{if} or \texttt{while} before the ``\texttt{:}''.
When you evaluate a boolean expression,
you get the value \texttt{True} or \texttt{False} as the result.

Consider the kind of integer assignment statement with which you are
now familiar:

\begin{Verbatim}
    num = count + 5
\end{Verbatim}

The expression on the right-hand side, the \texttt{count + 5}, is an
integer expression.  That is, when we evaluate it, we get an integer value
as the result.
%   And of course an integer value is exactly the right kind of
% thing to assign to an integer variable.

Now consider a similar-looking boolean assignment statement:

\begin{Verbatim}
    positive = num >= 0
\end{Verbatim}

The expression on the right-hand side, the \texttt{num >= 0}, is a
boolean expression.  That is, when we evaluate it, we get a boolean value
(True/False) as the result.
% And of course a boolean value is exactly the
% right kind of thing to assign to a boolean variable.
You can achieve
the same effect by the following more long-winded statement:

\begin{Verbatim}
    if num >= 0:
        positive = True
    else:
        positive = False
\end{Verbatim}

\pagebreak

The variable \texttt{positive} now stores a simple fact about the value of
 \texttt{num} at this point in the program.  (The value of  \texttt{num} might
subsequently change, of course, but the value of \texttt{positive} will not
change with it.)  If, later in the program, we wish to test
the value of \texttt{positive}, we need only write

\begin{Verbatim}
    if positive:
\end{Verbatim}

You can write \texttt{if positive == True:} if you prefer, but the
\texttt{== True} 
is redundant.  \texttt{positive} itself is either True or False.  
%Once the computer has evaluated \texttt{positive} 
%(established whether it is true or false) there is nothing more to do.  
We can also write

\begin{Verbatim}
    if not positive:
\end{Verbatim}

%(pronounced \emph{if not positive})
that is exactly the same as \texttt{if positive == False}. If
\texttt{positive} is True, then \texttt{not positive} is False, and
vice-versa.

Boolean variables are often called \emph{flags}.  The idea is that
% , leaving aside subtleties such as half-mast, 
a flag has basically two states -- either it's flying or it isn't.

So far we have constructed simple boolean expressions using the operators
introduced in the last chapter -- \texttt{x == y}, \texttt{s >= t} and so on --
now augmented with negation~(\verb+not+).
We can make more complex boolean expressions by joining simple ones
with the operators \verb!and! and \verb!or!.  For example,
we can express ``if x is a non-negative odd number'' as
\verb+if x >= 0 and x % 2 == 1:+. We can express ``if the name begins
with an A or an E'' as \texttt{if name[0:1] == 'A' or
  name[0:1] == 'E':}.  The rules for evaluating \emph{and}
and \emph{or} are as follows:

\vspace{1em}
\begin{tabular}{|l|lcr||lcr|}
\hline
& left & \verb!and! & right & left & \verb+or+ & right\\
\hline
\hline
1 & True & \textbf{True} & True&True&\textbf{True}&True\\
2 & True & \textbf{False} & False&True&\textbf{True}&False\\
3 & False & \textbf{False} & True&False&\textbf{True}&True\\
4 & False & \textbf{False} & False&False&\textbf{False}&False\\
\hline
\end{tabular}
\vspace{1em}

Taking line 2 as an example, this says that, given that you have two simple
boolean expressions joined by \emph{and} and that the one on the left is
True while the one on the right is False, the whole thing is False.  If,
however, you had the same two simple expressions joined by \emph{or}, the
whole thing would be True. As you can see, \emph{and} is True if and
only if both sides are True, otherwise it's False; \emph{or} is False
if and only if both sides are False, otherwise it's True.

\subsection*{Exercise C}

Given that \texttt{x} has the value 5, \texttt{y} has the value 20,
and \texttt{s} has the value `\texttt{Birkbeck}', decide whether these
expressions are True or False:

\begin{verbatim}
  x == 5 and y == 10
  x < 0 or y > 15
  y % x == 0 and len(s) == 8
  s[1:3] == 'Bir' or x // y > 0
\end{verbatim}


\subsection{Back to loops}
\label{subsec:backtoloops}

Returning to the problem of adding up a series of numbers, have a
look at this program:

\VerbatimInput[frame=single,label=Example]{src/s3Example3.py}

If we want to input a series of numbers, how will the program know
when we have put them all in?  That is the tricky part, which accounts
for the added complexity of this program.

The variable
\texttt{finished} is being used to help us detect when there are no more
numbers. It is initialised to \texttt{False}.  When the computer detects
that the last number (``0'') is introduced, it will be set to \texttt{True}.
When \texttt{finished} is True, it means that we have finished reading in
the input. The \texttt{while} loop begins by testing whether \texttt{finished}
is true or not.  If \texttt{finished} is not true, there is some more input
to read and we enter the loop. If \texttt{finished} is true, there are
no more numbers to input and we skip to the end of the loop.

The variable \texttt{total} is initialised to zero.
Each time round the loop, the computer reads a new value into \texttt{num}
and adds it to \texttt{total}. So \texttt{total} holds the total of all
the values input so far.

Actually the program only adds  \texttt{num} to \texttt{total} if a (non-zero) 
number has been entered. 
% The user will signal that there are no more numbers by keying in a special
% character.  (On Unix this is a Control-D; on PCs it is usually a Control-Z.
% If this is gobbledygook to you, just imagine that the user strikes a special
% key on the keyboard.)  
If the user enters something other than an integer 
-- perhaps a letter or a punctuation mark -- 
then the parsing of the input will fail 
and the program will stop, giving an error message.
% If the program is expecting an integer
% and instead receives something like ``abc'' or ``W'' or ``**!'', the input will fail.
% We can test whether the input has finished with the line \texttt{if (sc.hasNext())}.
% If this is false, then there is no more input available and we set \texttt{finished} to \texttt{true}
% in order to terminate the loop.

A real-life program ought not to respond to a user error by aborting
with a terse error message, though regrettably many of them do.
However, dealing with this problem properly would make this little program
more complicated than I want it to be at this stage.

\pagebreak

\textbf{You have to take some care in deciding whether a line should go in the
loop or outside it}.  This program, for example, is only slightly different
from the one above but it will perform differently:

\VerbatimInput[frame=single,label=Example]{src/s3Example4.py}

It resets \texttt{total} to zero \emph{each time round the loop.}  So
\texttt{total} gets set to zero,
has a value added to it, then gets set to zero, has another value added to
it, then gets set to zero again, and so on.  When the program finishes,
\texttt{total} does not hold the total of all the numbers, just the value
zero.

%\pagebreak

Here is another variation:

\VerbatimInput[frame=single,label=Example]{src/s3Example5.py}

This one has the \texttt{print} line inside the loop, so it outputs the value
of \texttt{total} each time round the loop.  If you keyed in the numbers
4, 5, 6, 7 and 8, then, instead of just getting the total (30) as the output,
you would get 4, 9, 15, 22 and then 30.

\subsection*{Exercise D}

Write a program that reads a series of numbers, ending with 0, and then tells you how
many numbers you have keyed in (other than the last 0).  For example, if you keyed in the
numbers~5, -10, 50, 22, -945, 12, 0 it would output `You have entered 6
numbers.'.


% \subsection{System libraries}

% The purpose of libraries is to provide the programmer with extensions
% to the language which can be pulled in, as and when needed. 
% Some libraries, known as the standard libraries, are provided with every
% Groovy implementation.  Other libraries can be created for special purposes.

% One team of programmers might produce a library of routines for another
% team of programmers to use.  When teams of programmers divide up the
% work on a large program in this way, it is all too easy
% for programmers in team A to choose a name for some item in their library
% and for programmers in team B to choose
% the same name for some quite unrelated item elsewhere in the program.
% This can be a serious nuisance.  To help contain the problem, Groovy
% provides \emph{packages}.  Team A declares one namespace and team B
% declares another.  Now it doesn't matter if they accidentally choose the
% same name.  Team B can still use names from A's package, but they have to
% tell the compiler specifically which names they are going to use.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

