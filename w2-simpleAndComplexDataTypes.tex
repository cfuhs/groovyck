


% Notes on style
%
% Identation
% Variable names
% Magic numbers, introducing final
%
% git commit file
%
% Reciprocal of Integer.parseInt() -> String.valueOf(int)
%
%
% PART-TIMERS
% Day 2: create account on GitHub like bbk-pij-2012-XX
%        for loops

\section{Introduction}
\label{sec:introduction}

Programs have lots of data, they are basically
ways of getting data, transforming data, and giving data back to the
world. 
%
Data types, as we have already seen, tell you which kinds of data you
have in your program. 

Computers store data in their memory in the form of bits. The word
``bit'' is a contraction of ``BInary digiT'', so a bit is
either~1~or~0, true or false, high or low, on or off. Bits are
organised in groups of 8 called \emph{bytes}. These bytes ---groups of
eight bits--- are used to store any data in the memory of the
computer. When you have got~1024~bytes, you have got a kilobyte or kB;
when you have~1024~kB you have got a megabyte or MB, and so on for
gigabytes~(GB), terabytes~(TB), and petabytes~(PB). Note that in
computing everything is measured in powers of~2 ($2^3 = 8, 2^{10} =
1024$) and not in powers of~10 as in normal life. That is because
computers count with bits~(2) and human beings\footnote{Not all humans
used only the ten fingers in their hands to count. Some languages like
French or Irish have remains of base-20 counting.} count with their
fingers~(10). 

\section{Simple data types}
\label{sec:simple-data-types}

Simple data types can be thought as boxes in the computer's
memory. Every time you declare a variable in your program, you can
think\footnote{This is only a metaphore and is not supposed to be an
  accurate description of how memory is managed on a modern
  computer. Explaining how things like the registers, the stack, and
  the heap work, the differences between actual machines and virtual
  machines, etc; are out of the scope of this document.} of the
computer as creating a little box in its memory to store your
variable. That box has two tags on it: one of them holds the name of
the variable and the other holds the type
(Figure~\ref{fig:github}). In the same way, you can think of
assignment as putting a value inside that box. 

\begin{figure}
  \centering
  \includegraphics{gfx/no_figure}
  \caption{Declaring a variable in Groovy can be seen as creating a
    box. The box has a tag for the name and another for the type.}
  \label{fig:var1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics{gfx/no_figure}
  \caption{Assigning a value to a variable can be seen as putting a
    value in the box. If there was something in the box, it is
    overwritten and lost forever.}
  \label{fig:var2}
\end{figure}

\subsection{Static typing and dynamic typing}
\label{sec:strong-typing-weak}

You have already seen that Groovy, as most languages, puts some
restrictions to what you can use as a ``name'' tag for your boxes. You
know that they have to start with a letter: ``count'' is a valid name
but ``/me'' or ``5thNumber'' are not. You also know that some words
cannot be used by the programmer for variables names because it would
be confusing, e.g. ``while'', ``if'', ``System'', or ``println''.

Many programming languages also place one restriction on the ``type''
tag: once you decide the type of a variable, you cannot change
it. This is like people having static opinions that they do not want
to change. This type of languages are called \emph{statically typed
  languages} and, contrary to people with fixed ideas, they are
not necessarily bad or obnoxious. Java is an example of
statically typed language. 

Some programming languages allow you to change the type of your
variables as you go along, so you can have a variable that sometimes
is an int and later in time is a boolean or a String. These languages
are called \emph{dynamically typed languages}. They have pros and cons
compared to their statically typed counterparts. Groovy is an example
of a dynamically typed language. The following code excerpt is valid
in Groovy but not in Java. In Java a variable cannot be a String, and
then a boolean, and then a String again. Note that \emph{true} is a
boolean while \emph{``true''} (in quotes) is a String. 

\begin{verbatim}
    String str = "This is a string";
    str = true;   // This is different to: str = "true"
    if (str) {
      str = "This is a different string";
    }
\end{verbatim}

There are many more things to know about typing in programming
languages (strong vs. weak, inferred vs. manifest, duck typing, and
much more) but for now it will not be necessary to go into those
details. 

\subsection{Most common simple types}
\label{sec:most-common-simple}

\subsubsection{Integer numbers}
\label{sec:integers}

Integers (\verb+int+) are probably the most used simple data type, as
integer numbers are used for two of the most common operations in
computing: counting and indexing. Integers use~32~bits of memory, and
an integer variable can hold values between~-2,147,483,648 and
2,147,483,647~(inclusive). This data type is large enough for the
numbers needed in~90\%~of programs most people write. We have already
seen how to use it: 

\begin{verbatim}
    int count = 1
\end{verbatim}

There are two versions of integers for some special uses. When a
program needs very large (positive or negative) values, there is a
type \verb+long+, for \emph{long integer}. It is called ``long''
because it uses 64~bits instead of 32, which means a long integer
variable can hold values between -9,223,372,036,854,775,808 and
9,223,372,036,854,775,807 (inclusive). There is also a ``short''
integer that uses only 16~bits of memory (\verb+short+); this was
sometimes useful when Java was first released in 1995 but is hardly
ever used with modern computers. 

\subsubsection{Floating-point (decimal/rational) numbers}
\label{sec:float-point-decim}

Not all numbers are integer. Examples of common non-integer numbers
include the result of a division of two integers where one is not a
multiple of the other, and real-measurements like your height, your
weight, and the distance between your workplace and your home (unless
you work at home). In maths, these are called real numbers. In
computing they are usually called floating-point numbers and are
represented as a list of significant numbers and an exponent. The term
``floating-point'' refers to the fact that the decimal point can "float",
that is, it can be placed anywhere in the number changing the exponent
accordingly. 

$$ 1.23 \cdot 10^{-3} = 123 \cdot 10^{-5} = 0.00123 \cdot 10^0 $$

In Groovy and in Java, real numbers are usually represented with the
simple data type \verb+double+, that uses 64~bits. There is also a
32-bit version called \verb+float+ but, as with \verb+short+, it is
hardly used today.

\paragraph{Important note.} 

Floating-point numbers do \emph{not} have infinite precision, and
operating with them can cause rounding errors. There is a special type
for representing real values where precision is paramount (like in
banking): \verb+BigDecimal+. 

\subsubsection{Boolean (binary) values}
\label{sec:bool-binary-valu}

This simple data type represents one bit of information. It can hold
the values \verb+true+ and \verb+false+. 

\subsubsection{Characters}
\label{sec:characters}

Text is composed of characters: 'a', 'b', 'c'\ldots The \verb+char+ is
used to represent characters. It uses 16~bits, meaning it can
represent any of~65,536~different characters. 

Actually, the 16~bits of a char represent a Unicode symbol. Unicode is
a computing industry standard for the consistent encoding,
representation and handling of text expressed in most of the world's
writing systems. It includes symbols from most writing systems in
the world, including alphabets like Latin, Cyrillic, Arabic, or
Hebrew; syllabaries like Japanese katakana and hiragana, or
Cherokee; and many more. 

You may have noticed that we have not mentioned String yet. This is
because String is a complex type. 

\section{Complex types}
\label{sec:complex-types}

Complex types are types of data that do not fit in a box, not even in
one of the big 64-bit boxes used for \verb+double+. Because they do
not fit in the ``boxes'', computers have to store them somewhere
else. However, they also need to know where they are\ldots~and that is
what the boxes are used. 

Modern computers have \emph{a lot} of memory. Long forgotten are the
days when Bill Gates said: ``640kB of memory should be enough for
everything''. Part of that memory is used for the boxes (in a part of
memory called ``the stack'') and most of the rest is used for
everything else, including complex data (that part is called, quite
unceremoniously, ``the heap''). 

When your Groovy or Java code uses some complex data, the computer
stores that data in some region of the heap ---identified by a \emph{memory
  address}; then it stores the address in a box in the stack, much in
the way it stores integers and booleans. This looks similar to
Figure~\ref{fig:compledata}. The memory address in the box can be seen
as ``pointing to'' the place in memory where the real data is
stored. For this reason, we are going to call it a \emph{pointer}. 

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{gfx/no_figure}
  \caption{A String is a type of complex data type. The data itself is stored in the heap and its address is stored in box in the stack ---pointing to it.}
  \label{fig:compledata}
\end{figure}

Using complex data types is different from using simple types in
several ways. For starters, as complex types are not stored in the
stack but in the heap, you have to \emph{allocate} memory-space in the
heap to store the data. This is done with the reserved word
\verb+new+; you also need brackets to pass arguments (as if using a
method: this is because complex types have something called a
\emph{constructor method} that we will in more detail later). We are
going to see now several examples, starting with the pervasive
Strings. 

Oh, one final note. Complex data types are usually called with capital
letters. This is not compulsory, but it is what everybody expects:
simple types with non-capital letters (e.g.~\verb+int+, \verb+double+)
and complex letters with capital letters (e.g.~\verb+String+,
\verb+Array+, \verb+List+, \verb+Customer+\ldots). If you do not
capitalise your complex types other people will get very confused when
they read your code. This is not only unpolite, it is also
unprofessional. 

\subsection{String}
\label{sec:string}

Strings are everywhere. Every program, except the most trivial, uses
strings: user names, passwords, addresses, configuration options, data
input from the keyboard, a webpage read through the Wi-Fi
connection\ldots~almost anything is a String. They are the most widely
used complex types. 

At their most basic, strings are sequences of characters. You already
know how to read a piece of text from the user: 

\begin{verbatim}
   String str = System.console().readLine()
\end{verbatim}

If you want to create a string in your program without reading it from
the user, the basic form of creating a string is like this: 

\begin{verbatim}
    String str = new String("This is a String")
\end{verbatim}

but you already know that this can be made in an easier way: 

\begin{verbatim}
    String str = "This is a String"
\end{verbatim}

The former two statements are equivalent in Groovy\footnote{They are
  NOT equivalent in Java, but we will learn why when the time
  comes.}, only the second is more convenient and most people use it
instead of the other. 

% Simple proof of non-equivalence in Java:
% 
% public class StringTest {
%    public static void main(String args[]) {
% 	 String s1 = System.console().readLine();
% 	 String s2 = new String("QWE");
% 	 String s3 = "QWE";
% 	 if (s1 == s2) System.out.println( "s1 == s2");
% 	 if (s2 == s3) System.out.println( "s2 == s3");
% 	 if (s3 == s1) System.out.println( "s3 == s1");
%    }
% }

Like with any other complex type, we can make set the pointer of a
String not to point to any address in memory. This can be useful in
some cases that will become clearer as we learn more about
programming, including error detection, release of used memory, and
garbage collection. To make a pointer point to nowhere, we use the
reserved word~\verb+null+ (with non-capital letters).

\begin{verbatim}
    String str
    str = null
\end{verbatim}

A pointer pointing to null is called a \emph{null pointer}. This
basically means that the address in the box is zero; the computer
knows there is never anything at address zero, so it knows a null
pointer is not being used to point to any complex
data~(Figure~\ref{fig:nullpiounter}).

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{gfx/no_figure}
  %TODO
  \caption{A null pointer is basically a zero address}
  \label{fig:nullpiounter}
\end{figure}

You already know that you can do some things with strings using
\emph{methods}. Although we are going to learn more about methods on
the next section, we can introduce some of them now. 

% more on the methods of String here...
% subString, length, charAt


% at the end: method split() -> links with Arrays

% Arrays

% methods: length


% Your own structures: Classes

% A final note on terminology

% simple and complex = primitive and classes


%%%%%%%%%%%%%%5

% Methods, functions


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

