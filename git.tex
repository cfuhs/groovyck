\section{Source code version control}
\label{sec:source-code-version}

What is version control? It is something as simple (and as difficult
to make right) as keeping track of changes in some piece of work. You
are probably familar with some very rudimentary version of version
control. Have you ever listed the documents in a folder and seen
something similar to this?

\begin{itemize}
\item myDocument
\item myDocument-2
\item myDocument-3
\item myDocument-final
\item myDocument-final2
\item myDocument-final-final
\item myDocument-definitive
\item myDocument-defitive-USE-THIS-ONE
\end{itemize}

If so, you already understand the most important idea behind version
control: our work is never created in one go, it changes over time and
sometimes we want to make sure we can go back in time to a former
version of it\ldots just in case. 

Many modern programs have version control embedded into them,
e.g. word processors like Microsoft Word, OpenOffice Write, or Google
Docs (also known as Google Drive). Very often they just track the
changes made to the document, sometimes they allow the user to go back
and forth in time to review, accept, or discard changes. This is also
very common in wiki sites like the Wikipedia. 

% TODO: add a screenshot of the version control in wikipedia here. 

Version control systems were initially created to track changes in
\emph{source code}. They were created by programmers for
programmers. We have come a long way since those days, and now version
control is spread over many different applications, but they still aim
at two main features: 

\begin{description}
\item[Reversibility: ] the capacity of going back in time if you mess
  up and introduce bugs in your code; sorry, \emph{when} you introduce
  bugs in your code.
\item[Concurrency: ] the capacity of working together with other
  people on the same project, on the same file. 
\end{description}

These two capacities are basic for any modern programmer, and that is
why version control is (or should be) part of every programmer's daily
life. Modern programs are big and complex, and several programmers
work on them. Without appropriate version control, they cannot work at
the same time: they need to take turns, pass the baton\ldots this is
really unproductive, good programmers do not work like
that. Additionally, programmers ---even good programmers, as long as
they are human--- make mistakes all the time, sometimes serious
mistakes that break their programs completely, and they need to go
back in time to the point where everything was working fine and start
again (in large and complicated programs, this can be a long time
before).

In this chapter we will learn to make version control on your source
code files \emph{right}, not as shown above (myProgramOLD.groovy,
etc). And we will use a program for doing so called \emph{Git}.

\section{Git}
\label{sec:git}

There are many programs for performing source code version control
nowadays. For this course, we are using Git, a version control system
created by Linus Torvalds, the same guy that created Linux. It is not
difficult to use but it is very powerful. 

Other very common version control systems are Subversion (also known
as svn) and Mercurial. There are many more. There are many sources
online, starting with Wikipedia, that will tell you the history of
version control, the differences between different systems, and much
more. I encourage you to go and read about it if you think the topic
is fascinating. If you just want to learn to use Git to help you in
your life as a programmer, this section will help you learn the
basics. 

As you can imagine, a full book could be written about all the
possibilities and options that come with Git. Actually, there are
several of them already. In this section I will only present the most
important 10\% of Git, which will take you 90\% of the way. 

\section{Starting a new project}
\label{sec:starting-new-project}

Let's start by creating a new programming project. Create a new folder
where you will put your programs. Now we want to start keeping track
of all changes. Assuming Git is installed in your system, and that you
are on the right folder, you only need to type \verb+git init+. With
this simple command, you have told Git to \emph{be ready} to keep 
track of whatever happens in this folder. So the full initialisation
of a complex complete version control system with Git looks like this: 

\begin{verbatim}
    > mkdir MyProject
    > cd MyProject
    > git init
\end{verbatim}

That was easy, wasn't it? Now you can keep track of all changes to
your files in this folder. Moving on\ldots

\section{Keeping track of changes}
\label{sec:keep-track-chang}

Now it is time to write some code. For example, we could create a
simple \emph{Hello World} application in Groovy. In other words, we
will edit a file called \verb+helloworld.groovy+ and write on it:

\begin{verbatim}
    print "Hello World!"
\end{verbatim}

If we execute this little program, it will print the words ``Hello
World!'' on the screen. So far, so good. Time to start filling up our
version journal! 

The first step is to tell Git that we want to keep track of this
file. In other words, we \emph{add} it to the list of files under
Git's responsibility. 

\begin{verbatim}
    > git add helloworld.groovy
\end{verbatim}

And now we must perform the most important operation in any version control
system: \emph{committing} our changes. 

\begin{verbatim}
    > git commit
\end{verbatim}

You will be asked to introduce some description of this \emph{commit}
is about. Git adds automatically information about which files are
committed and what changes have been performed on them. The programmer
must provide some additional information, a short message to explain
to other programmers what the changes are about. Note that ``other
programmers'' can be yourself in two weeks time, when you have
forgotten what you committed at this point. Typical messages are
``First commit'', ``Fixed bug \#1304'', ``Added a new feature
for\ldots''; examples of bad non-informative commit messages are ``new
commit'', ``More code'', or ``Fixed it AT LAST!''. Write whatever you
want, but make a (small) effort to think what message will be useful
for people reading it in the future.

When you finish writing your commit description, save it and close the
editor. The commit will be performed, and you will be given some
output from Git. That output will include information about the
branch, the identifier for this commit, your commit text, and some
statistics about what the commit did (\emph{see
  Figure~\ref{fig:git-example-1}}). 

\begin{figure}[htbp!]
  \centering
  % TODO
  \caption{Example of commit message in Git}
  \label{fig:git-example-1}
\end{figure}

Now your project has a history! It looks more or less like this:

\begin{figure}[htbp!]
  \centering
  % TODO
  \caption{Initial history of this project}
  \label{fig:git-example-2}
\end{figure}

Let's say we are not happy with our program. It does not do much. We
can modify the program to look like this:


\begin{verbatim}
    println "Hello World!"
    println "What's your name?"
    String s = System.console().readline()
    println "Hello " + s + "!"
\end{verbatim}

Now we can commit again (\verb+git add helloworld.groovy+,
\verb+git commit+, plus a commit description). Then we try to run
it\ldots Groovy will complain. We have messed up! At this point, we
have two options:

\begin{itemize}
\item If we know where the problem is (and in this simple example, we
  do) we can just fix it and commit again. A good commit message would
  be ``Fixed typo in line 3: readline() should be readLine()''.
\item If we did not know where the problem is, as it is usually the
  case in big programs, we can go back until we find the commit in
  which the problem started. Looking at the changes on that commit we
  can see how the \emph{bug} was introduced. Thanks to version
  control, finding bugs is much easier. 
\end{itemize}

The simplest way to travel in time is by looking at the change log of
a file, and we are going to see how to do that in the next section. 

% TODO: continue here

diff
clone
log
push
config (change name, email)
change .gitignore
rm
pull
help



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

