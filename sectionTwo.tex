\section{Arithmetic expressions}

In this section we will discuss arithmetic expressions, identifiers and comments, string variables, conditionals, two-way branches,  and the ASCII code set.

Groovy uses the following arithmetic operators (amongst others):

\begin{tabular}{ll}
\verb!+! & addition\\
\verb!-! &subtraction\\
\verb!*! &multiplication\\
\verb!/! &division\\
\verb!%! &modulo\\
\end{tabular}

The last one is perhaps unfamiliar.  The result of \verb!x \% y! ("x mod y")
is the remainder that you get after dividing the integer x by the integer y.
For example, \verb!13 % 5! is \verb!3!; \verb!18 % 4! is \verb!2!; \verb!21 % 7! is \verb!0!, and \verb!4 % 6 is 4! (6 into
4 won't go, remainder 4).  \verb!num = 20 \% 7! would assign the value 6
to \verb!num!.

How does the computer evaluate an expression if there is more than one
operator in it?  For example, given \verb!2 + 3 * 4!, does it do the addition
first, thus getting \verb!5 * 4!, which comes to 20, or does it do the multiplication
first, thus getting \verb!2 + 12!, which comes to 14?  Groovy, in common with other
programming languages and with mathematical convention in general, gives
precedence to *, / and \% over + and \verb!-!.  This means that, in the example,
it does the multiplication first and gets 14.

If the arithmetic operators are at the same level of precedence, it takes them left
to right.  \verb!10 - 5 - 2! comes to 3, not 7.  You can always override the
order of precedence by putting brackets into the expression; (2 + 3) * 4
comes to 20, and \verb!10 - (5 - 2)! comes to 7.

Some words of warning are needed about division.
If the operands are both of type \verb!int!, the result of a division
is also of type \verb!int!.  For example, the result
of 7 / 2 is 3, not 3.5.  If \verb!num!, which is an \verb!int!, had the value 7,
then \verb!num / 2! would be 3, and \verb!18 / num! would be 2.  Computers
are perfectly capable of handling floating-point numbers such as 3.5, but
the type of division carried out depends on the type of the operands.
In order to get a result of 3.5, it would be necessary for at least one
of the operands to be a floating-point number, such as \verb!7 / 2.0!.  But if
they are both of type \verb!int!, you get integer division with an integer result.  I'm not going to say much about floating-point numbers in
this introduction.

A computer would get into difficulty if it tried to divide by zero.
Consequently, the system makes sure that it never does.
If a program tries to get the computer to divide by zero, the program
is unceremoniously terminated, usually with an error message on the
screen.

\subsection*{Exercise 2A}

Write down the output of this program:

\VerbatimInput[frame=single,label=Example]{src/s2Example.groovy}

To check your answers, click on  Answers to the exercises. ** NOT DONE **

\subsection{Identifiers and comments}

I said earlier that you could use more or less any names for your variables.
I now need to qualify that.

The names that the programmer invents are called \emph{identifiers}.  The
rules for forming identifiers are that the first character can be a letter
(upper or lower case) and subsequent characters can be letters or digits
or underscores.  (Actually the first character can be an underscore but
identifiers beginning with an underscore are often used by system programs
and are best avoided.)  Other characters are not allowed.  Groovy is
case-sensitive, so \verb!Num!, for example, is a different identifier from
 \verb!num!.

The only other restriction is that you cannot use any of the language's keywords
as an identifier.  You couldn't use \verb!int! as the name of a variable,
for example.  There are XX keywords but most of them are words that you
are unlikely to choose.
Ones that you might accidentally hit upon are \texttt{break, case, catch, class,
const, continue, double, finally, float, import, long, new, return,
short, switch, this, throw} and \texttt{try}   You should also avoid
using words which, though not technically keywords, have special significance
in the language, such as \verb!println! and \verb!String!.

Programmers often use very short names for variables, such as \verb!i, n! or
\verb!x! for integers.  There is no harm in this if the variable is used to
do an obvious job, such as counting the number of times the program goes round
a loop and its purpose is immediately clear from the context.  If, however, its
function is not so obvious, it should be given a name that
gives a clue as to the role it plays in the program.  If a variable is
holding the total of a series of integers and another is holding the
largest of a series of integers, for example, call them \verb!total!
and \verb!max! rather than \verb!x! and \verb!y!.

The aim in programming is to write programs that are "self-documenting",
meaning that a (human) reader can understand them without having to read
any supplementary documentation.  A good choice of identifiers helps to
make a program self-documenting.

Comments provide another way to help the human reader to understand a
program.  Anything on a line after "//" is ignored by the compiler,
so you can use this to annotate your program.  You might summarise
what a chunk of program is doing:
\begin{Verbatim}
// sorts numbers into ascending order
\end{Verbatim}
or explain the purpose of an obscure bit:
\begin{Verbatim}
x = x * 100 / y   // x as percent of y
\end{Verbatim}

Comments should be few and helpful.  Do not clutter your programs with
statements of the obvious such as:
\begin{Verbatim}
num = num + 1   // add 1 to num
\end{Verbatim}
Judicious use of comments can add greatly to a program's readability, but they
are second best to self-documentation.  Their weakness is that it is all too
easy for a programmer to modify the program but forget to make any
corresponding modification to the comments, so the comments no longer quite
go with the program.  At worst, the comments can become so out-of-date as
to be positively misleading.

\subsection{Exercise 2B}

Say for each of the following whether it is a valid identifier
in Groovy and, if not, why not:
\begin{Verbatim}
BBC, Groovy, y2k, Y2K, old, new, 3GL, a.out, remove,
first-choice, 2nd_choice, third_choice, constant, UNION
\end{Verbatim}

To check your answers, click on Answers to the exercises. ** NOT DONE **

\subsection{String variables}

As well as variables of type  \verb!int! we can have variables of type
 \verb!String!.  
We could declare a  \verb!String! variable as follows:
\begin{Verbatim}
String s
\end{Verbatim}
and also initialise it if we wanted to:
\begin{Verbatim}
String s = "Wallace"
\end{Verbatim}
We can change the value of a string with assignment:
\begin{Verbatim}
s = "Feathers McGraw"
\end{Verbatim}
or, if we had two strings \verb!s! and \verb!t!:
\begin{Verbatim}
s = t   // s and t do not need to be the same length
\end{Verbatim}
We can also use \verb!sc.next()! to give a new value to a string:
\begin{Verbatim}
s = sc.next()
\end{Verbatim}
When this statement is executed, the computer will skip any leading spaces
or tabs or blank lines until it comes to a non-space character.  This
will be the first character of the string \verb!s!.  Then it picks up
characters and adds them to \verb!s! until it comes to a space, tab or
end-of-line, at which point it stops.  So, if the input was:
\begin{Verbatim}
                             Silverdale
\end{Verbatim}
the value in \verb!s! would be "\verb!Silverdale!" (without the leading spaces).
If the input was:
\begin{Verbatim}
Warton Crag
\end{Verbatim}
the value in \verb!s! would be "\verb!Warton!", since it would stop at the space.

Another useful input function with strings is \verb!getLine()!, as in
\begin{Verbatim}
s = sc.getLine()
!\end{Verbatim}
This takes the whole of the input line and puts it into  \verb!s!, spaces and
tabs included.  Executing this statement with the input line
\begin{Verbatim}
         Silverdale,        Warton Crag  (with the line ending after "Crag") 
\end{Verbatim}
would put the whole line into \verb!s!, including all the spaces, from
the leftmost of the leading spaces up to the "g" of "Crag".

The "+" operator has special significance with strings; it is the
\emph{concatenation} operator.  For example, if  \verb!s! had the value
"\verb!Wallace!" and \verb!t! had the value "\verb!Grommit!", then
\begin{Verbatim}
s = s + " and " + t
!\end{Verbatim}
would give  \verb!s! the value "\verb!Wallace and Grommit!".

If you want to know how long a string is, you can find out with the \verb!length!
function.  If  \verb!s! is the string, \verb!s.length()! (don't forget the
brackets) is the length.  You could say, for example:
\begin{Verbatim}
String s;
s = sc.next()
int len = s.length()
\end{Verbatim}
And you can obtain a substring of a string with the \verb!substring! function.
For example if  \verb!s! has the value "\verb!Silverdale!", then
\verb!s.substring(0,6)! will give you the first six letters, i.e., the string
"\verb!Silver!".  The first number in brackets after the \verb!substring!
says where you want the substring to begin, and the second number says how
long you want it to be.  Note that the initial character of the string
is at position 0, not position 1.  If you leave out the second number,
you get the rest of the string.  For example, \verb!s.substring(6)! would
give you "\verb!dale!", i.e., the tail end of the string beginning at character 6
('d' is character 6, not 7, because the first one is character 0).

You can output substrings with \verb!print! or assign them to other
strings or combine them with the "+" operator.  For example:

\VerbatimInput[frame=single,label=Example]{src/s2Example2.groovy}

will output "soft ices".

\subsection*{Exercise 2C}

Say what the output of the following program fragment would be:

\VerbatimInput[frame=single,label=Example]{src/s2Example3.groovy}

To check your answers, click on Answers to the exercises. ** TO DO **

\subsection{Conditionals (\texttt{if} statements)}

To write anything more than very straightforward programs we need some way
of getting the computer to make choices.
We do this in Groovy with the keyword \verb!if!.
We can write, for example,

\VerbatimInput[frame=single,label=Example]{src/s2Example4.groovy}

When the computer executes this, it first sees whether the variable \verb!num!
currently has the value 180 or not.  If it does, the computer displays
its message; if it doesn't, the computer ignores the  \verb!println! line
and goes on to the next line.

Note that the conditional expression (\verb!num == 180!) has to be
in brackets.

Note also that, to test whether  \verb!num! has the value 180
or not, we have to write \verb!if (num == 180)! and not \verb!if (num = 180)!.
We have to remember to hit the "=" key twice.
This is a serious nuisance in Groovy, especially for beginners.
It comes about because the language uses the "=" operator for a different
purpose, namely assignment.  \verb!num = 180! does not mean, " \verb!num! is
equal to 180."  It means, "Give the value 180 to  \verb!num!."  You may feel
that it is obvious that assignment is not what is intended in
\verb!if (num = 180)!, but unfortunately the rules of the language allow
an assignment at this point, and that is
how the computer will interpret it.  The line \verb!if (num = 180)!,
with one "=" sign, will actually give the value 180 to  \verb!num!.
You have been warned.

The following program takes two numbers and displays a message if they happen
to be the same:

\VerbatimInput[frame=single,label=Example]{src/s2Example5.groovy}

Conditional expressions --- the kind that follow an \verb!if! -
can be formed using the following operators:

\begin{tabular}{ll}
\verb!==! &is equal to\\
\verb!!=! &is not equal to\\
\verb!>! &is greater than\\
\verb!<! &is less than\\
\verb!>=! & is greater than or equal to\\
\verb!<=! &is less than or equal to\\
\end{tabular}

When these operators are used with integers, their meaning is obvious,
but they can also be used with strings.  Here their meaning corresponds
to something like alphabetical order.  For instance, \verb!if (s < t)!,
where  \verb!s! and \verb!t! are strings means "If  \verb!s! comes before \verb!t!
in alphabetical order."  So it would be true if  \verb!s! had the value
"\verb!Birkbeck!" and \verb!t! had the value "\verb!College!".  All the
upper-case letters come before the lower-case, so \verb!(s < t)! would
still be true if  \verb!s! had the value "\verb!Zebra!" and \verb!t! had the
value "\verb!antelope!" (upper-case 'Z' comes before lower-case 'a').

But what about strings that contain non-alphabetic characters?   Would  \verb!s!
come before \verb!t! if  \verb!s! had the value "\verb!#+*!" and \verb!t! had the
value "\verb!$&!!"?  To find the answer we have to consult the
\emph{UNICODE table} -- the Universal Character Set.
UNICODE
defines a particular ordering of all the characters
on the keyboard.  (There are other orderings in use, notably EBCDIC which
is used on IBM mainframe computers,  and ASCII, which was adopted by PCs,
which became the de facto standard for english based languages.)   UNICODE table tells us that the
character '\#' comes before the character "\verb!$!", for instance.
The latest version of Unicode consists of a repertoire of more than 109,000 characters covering 93 different scripts

There is a listing of the printable characters in the UNICODE set at the
end of this section.  Some points worth remembering are:

\begin{itemize}
\item
The space character comes before all the printable characters.
\item
Numerals come in the order you'd expect, from '0' to '9'.
\item
Letters come in the order you'd expect, from 'A' to 'Z' and from 'a' to 'z'.
\item
Numerals come before upper-case letters and upper-case letters come before lower-case.
\end{itemize}

\subsection*{Exercise 2D}

Say, for each of the following, whether \verb!s < t! would be
true or false, assuming that  \verb!s! had the value on the left and \verb!t!
had the value on the right:

\begin{tabular}{ll}
\verb!"A"! & \verb!"9"!\\
\verb!"Zurich"! & \verb!"acapulco"!\\
\verb!"Abba"! & \verb!"ABBA"!\\
\verb!"long_thing_with_a_$"! & \verb!"long_thing_with_a_&"!\\
\verb!"King's College"! & \verb!"King Kong"!\\
\end{tabular}

To check your answers, click on  Answers to the exercises. ** TO DO **

\subsection{Two-way branches (\texttt{if .. else})}

The following program fragment tells students whether they have passed their exam:

\VerbatimInput[frame=single,label=Example]{src/s2Example6.groovy}

What happens, in the case of this exam mark program, if a student's mark is
< 40?  The program does nothing.  This kind of \verb!if! statement is a
one-way branch.  If the condition is true, we do something; if not, we do
nothing.  But in this case
this seems unsatisfactory.  If the exam mark is < 40, we would like
it to display "I'm afraid you have failed."  We could arrange this by
including another test --- \verb!if (exammark < 40)!  --- or, better, we could
do it by using the keyword \verb!else!, thus:

\VerbatimInput[frame=single,label=Example]{src/s2Example7.groovy}

The  \verb!else! turns a one-way branch into a two-way branch.  If the condition
is true, do this; otherwise, do that.

\subsection*{Exercise 2E}

Write a program that takes two numbers, one representing a
husband's salary and the other representing the wife's, and tells them
whether or not their combined income makes them due for tax at the higher rate
(exceeding \pounds 40000).

To check your answers, click on Answers to the exercises. ** TO DO **

Let's suppose we want to extend the exam mark program so that candidates who
have passed get two lines of output, thus:

\VerbatimInput[frame=single,label=Example]{src/s2Example8.groovy}

Unfortunately the compiler will object to this.  It will say that it has
encountered an  \verb!else! in an unexpected place.  What is the problem?

Although the layout of this program suggests that the "satisfactory" line
and the "proceed with project" line go together, there is nothing to
indicate this to the compiler.  As I pointed out earlier, the compiler
pretty much ignores the layout.  So far as the compiler is concerned,
we have a one-way  \verb!if! statement (the kind without an  \verb!else!) which ends
at the first \verb!endl;!  Then there is another  \verb!cout! line (proceed with
project) which is not part of the  \verb!if! statement; it's just the first
line of the rest of the program.  And then, unexpectedly,
appears an  \verb!else!.

We need some way of bracketing together
the "satisfactory" line and the "proceed with project" line so as to make
it clear to the compiler that both of these lines come under the  \verb!if!.
This is how we do it in Groovy:

\VerbatimInput[frame=single,label=Example]{src/s2Example9.groovy}

The curly braces have the effect of grouping all the statements inside
them into a programming unit called a \emph{block}.  If the exam mark is
>= 40, the whole of the block is executed.  If the mark is < 40, the
computer skips to the  \verb!else! and executes the "I'm afraid" line.

You will find that different programmers, and different textbooks, have
different ideas about the precise placement of the curly braces.  Some would
set out the above fragment as:

\VerbatimInput[frame=single,label=Example]{src/s2Example10.groovy}

and there are other variations.  Personally I like to see the opening and
closing curly braces lined up vertically.  It helps the reader to see how
they match up.

\subsection*{Exercise 2F}

Extend the above program fragment so that all the candidates
get two lines of output, the unsuccessful ones getting "I'm afraid you
have failed," and "You may re-enter next year."

To check your answers, click on Answers to the exercises. ** TO DO **

Suppose now that we wanted to give a different message to candidates who
had done exceptionally well.  Our first thought might be as follows:

\VerbatimInput[frame=single,label=Example]{src/s2Example11.groovy}

But this would not work quite right.  It's OK for candidates with marks < 70,
but candidates with marks >= 70 would get the following output:
\begin{Verbatim}
An exceptional result
We expect a first-class project from you.
A satisfactory result
You may proceed with your project.
\end{Verbatim}
The problem is that if a mark is >= 70, it is also > 40.  The first
condition is true, so we get the "exceptional" part, but then the second
condition is also true, so we get the "satisfactory" part.  We want to
proceed to the >= 40 test only if the mark is < 70.  We need another  \verb!else!:

\VerbatimInput[frame=single,label=Example]{src/s2Example12.groovy}

\subsection*{Exercise 2G}

Write a program which takes two integers as input.
If the first is exactly divisible
by the second (such as 10 and 5 or 24 and 8, but not 10 and 3 or 24 and 7)
it outputs "Yes", otherwise "No", except when the second
is zero, in which case it outputs "Cannot divide by zero."

\subsection*{Exercise 2H}

Write a program which takes an integer as its input representing the time
using the 24-hour clock.  930 is 9.30 am; 2345 is 11.45 pm.  Midnight is
zero.  The program responds with a suitable greeting for the time of day.
If you want to make this a bit harder, make the program respond with a "?"
if the time represented by the number is impossible, such as 2400, -5 or
1163.

To check your answers, click on Answers to the exercises. ** TO DO **

% \subsection{The UNICODE character set}

% The portion of the UNICODE table dealing with printable characters is as
% follows.  The numbers indicate the character's position in the UNICODE
% character set;  upper-case 'A', for example, is character number 65.
% Character number 32 is a space.
