
\section{Input/Output (I/O)}
\label{sec:inputoutput-io}

Computer programs are just processors of data. They take some data as
input, they return some data as output. Up to now, all the data that
our little programs have processed was either provided by a human user
or already included in the program. In the real world, however, the
most usual sources of data are computers; either the computer where
the program is running (local files), a computer in the vicinity (a
database server), or a remote computer (remote resources through the
net). 

We are going to learn now how to use the first of these three sources
of information: how to read from the local disk and how to write to
the local disk. 

\subsection{The basics}
\label{sec:basics}

\subsubsection{File systems}
\label{sec:filesystems}

Computers have different levels of memory, but there is a clear
separation between primary and secondary memory. Primary memory is
faster but requires electricity to run; if the computer is switched
on, the contents of the memory are lost. Secondary memory is slower,
but its contents are persistent, i.e.~they are still there when the
computer is switched off and on again. Seconday memory is usually
implemented in the form of a hard disk or so-called flash
memories. It is usually referred to as ``disk'', regardless of the
actual technology used for it. 

Data is stored in secondary memory in files\footnote{This name, as
  many others, comes from an ancient era where files, archives,
  directories, and folders were physical objects that contained
  documents or data.}  
The file system is a subsystem of the operating
systems that keeps all your files in place, and provides a way of
accessing them. Usually this is done by means of hierarchies: there is
one folder/directory at the top level of the hierarchy (called the
\emph{root}), which contains some files and subdirectories, each of
these subdirectories may contain files and/or subdirectories, etc. In
order to access a file \verb+taxForm2012.odt+ inside a folder
\verb+taxes+, inside a folder \verb+MyStuff+, you may access it with a
route like: 

\begin{verbatim}
    /home/john/MyStuff/taxes/taxForm2012.odt                     (unix)
    c:\Documents and Settings\john\MyStuff\taxes\taxForm2012.odt (windows)
    ./MyStuff/taxes/taxForm2012.odt
\end{verbatim}

Different operating systems use different conventions for the root of
the tree of subdirectories and the separation of the levels of
hieararchy. Unix systems (e.g.~Linux, MacOS/X) use a single root
(``/'') for the whole filesystem, and separate directories using a
slash (``/''). Windows use different roots, one per physycal device or
partition (C:, D:, etc) and separate directories with a 
backslash~(``\verb+\+''). 

File routes that start at the root are called \emph{absolute} and
those that do not are called \emph{relative} (because they point to
different files depending on the current directory). Absolute routes in
unix always start with ``/'', but in Windows they can start in
different ways (e.g.~''\verb+C:\+'', ''\verb+D:\+'', ''\verb+\+'',
etc) because there are many roots. Relative routes may start with
a dot (meaning ``current directory'') but they usually start with the
name of a file or directory. 


\subsubsection{Process}
\label{sec:process}

The process of reading from / writing to an external source always
follows the same sequence of steps:

\begin{enumerate}
\item Open the resource (e.g.~file). If it cannot be opened, finish.
\item Read from and write to the resource.
\item Close the resource. 
\end{enumerate}

This process is the basis of all interaction with external data
sources, including files, databases, and remote resources\footnote{As
  we will see, in the network resources this is usually hidden from
  the programmer.}.
It is \emph{very important to close the resource} (file, database
connection, remote connection / socket) at the
end. Otherwise, the resource may not be accessed by other programs (or
even by your same program in some situations). In a way, closing a
data source is like releasing memory that you no longer
used. Unfortunately, it is not possible to create something like a
garbage collector for data sources, so programmers have to close their
data sources manually.

\subsection{Files in Java}
\label{sec:files-java}

File names are represented in Java by the class \verb+File+ in package
\verb+java.io+. It is important to note that Java uses the unix
tradition of considering (almost) everything a file: letters and
spreadsheets are files, but so are directories for example. Therefore,
an object of class \verb+File+ can represent the name of an actual
file or the name of a directory.

This class implements a lot of methods that are useful when
interacting with the local disks. Some of the most commonly used
include: 
\verb+createNewFile()+, 
\verb+delete()+, 
\verb+exists()+, 
\verb+isDirectory()+, 
\verb+isFile()+, 
\verb+length()+, 
\verb+list()+ (lists all files in a directory), 
and
\verb+mkdir()+ (creates a directory). There are many other useful
methods, as you can see on the JavaDoc of \verb+File+\footnote{As you
  have done many times in the past weeks, you can find the JavaDoc of
  this class by searching for ``java file''. Usually the first link
  will be the documentation of the class. }, and most of them have
quite self-descriptive name. . 

Using the \verb+File+ class to get a pointer to a file (or directory)
on disk is really easy: 

\begin{verbatim}
    String filename = "filename.txt"; 
    File file = new File(filename);
\end{verbatim}

The name of the file (\verb+filename+) can be any valid route,
e.g. \verb+/home/john/file.odt+. However, there are two things that a
Java developer should keep in mind to make sure that Java programs can
run on any computer: 

\begin{description}
\item[Slash as separator] You should use slash (``/'') as a separator,
  as it works in both unix and windows systems. For extra security,
  you can use the static final field \verb+File.separator+ that always
  has the right value for the operating system the Java Virtual
  Machine is running on. Do not use names like \verb+.\myFile.txt+;
  use \verb+./myFile.txt+ instead or, to make sure it works in all
  computers:

\begin{verbatim}
    ''.'' + File.separator + ''myFile.txt''
\end{verbatim}

\item[Relative filenames: ] Your filenames should always be
  \emph{relative}, rather than absolute. Absolute routes will not work
  among different operating systems. For example, \verb+myFile.txt+ and
  \verb+./myStuff/myFile.txt+ are fine, but \verb+c:\myStuff\file.txt+
  is not. 
\end{description}

\subsection{Reading from and writing to files}
\label{sec:reading-from-writing}

Once we have a pointer to a file (through its name) we can try to open
it as we said in Section~\ref{sec:process}. Note that the file may or
may not exist. The \verb+File+ object is only a reference to the
name. If we want to know whether it exists, we can execute the
\verb+exists()+ method. 

\verb+File+ objects cannot be directly opened in Java. Instead, an
input source of data (a \verb+Reader+) can be created with a file and
it is this source that is opened (and closed at the end) to
read. Conversely, an output sink of data (a \verb+Writer+) can be
created with a file, opened, write to, and closed. 

% TODO: talk about streams?

\subsubsection{Reader}
\label{sec:reader}

\verb+Reader+ is the abstract class from which all other reader
classes descend, and it defines methods to read characters, either one
by one or many in one go. 
There are three main reader classes, each of them with
a different purpose: 

\begin{description}
\item[FileReader: ] The class for reading from text files\footnote{For
  binary files you use a FileInputStream.} (including
  common format like CSV and XML (and XML-based formats like
  OpenDocument). 
\item[BufferedReader: ] A general-purpose reader that reads characters
  from a character input stream, bufferring them for efficiency. This
  means that you do not need to read character by character. It
  provides useful methods like \verb+readLine()+.
\item[StringReader: ] A string-based reader that uses a string as the
  input source of data. Can be useful if the data is already stored in
  a String instead of being read from a file or network connection. 
\end{description}

\paragraph{Open data source}
\label{sec:open-data-source}

A \verb+Reader+ is automatically open at creation (with
\verb+new+). There is no need to explicitly open it with a method
call. 

The usual idiom to create an input source
combines a \verb+FileReader+ (to read from a
\verb+File+) with a \verb+BufferedReader+ to have access to buffered
data input and the \verb+readLine()+ method. If a \verb+FileReader+ is
directly used (without buffering), the performance of the application
may suffer. 

\begin{verbatim}
    File file = new File("here/be/the/route/to/the/file");
    BufferedReader in = new BufferedReader(new FileReader(file); 
\end{verbatim}

Creation of a \verb+FileReader+ may throw an
\verb+FileNotFoundException+, and this is a checked exception. This
means that the code above must be placed inside a \verb+try+/\verb+catch+
construct or the method must declare that it \verb+throws+ this
exception. 

\paragraph{Reading from the source}
\label{sec:reading-from-source}

Once the data source is opened, we can read from it line by line using
\verb+readLine()+. When we reach the end of the file,
\verb+readLine()+ returns \verb+null+. 


\paragraph{Closing the source}
\label{sec:closing-source}

When we have finished with reading from the file, we must close the
data source. This is easily done with the \verb+close()+ method. 

\begin{verbatim}
     in.close();
\end{verbatim}

Alert readers may have noticed that this poses a small problem. Look
at the following code: 

\begin{verbatim}
01    File file = new File("file.csv");
02    try {
03        BufferedReader in = new BufferedReader(new FileReader(file); 
04        while ((String line = in.readLine) != null) {
05            // ... do things with the data here
06        }
07        in.close();
08    } catch (IOException ex) {
09        ex.printStackTrace();
10    } catch (FileNotFoundException ex) {
11        System.out.println("File " + file + " does not exist.");
12    }    
\end{verbatim}

If a \verb+FileNotFoundException+ is thrown on line 03 nothing bad
happens; it is dealt with at the appropiate catch block. But what
happens if an \verb+IOException+ is thrown at line 04 or inside the
loop? The execution flow will jump to the catch clause on line 08,
skipping line 07 and the data source will never be closed! 

\begin{itemize}
\item We cannot move line 07 out of the \verb+try+ block because
  \verb+in+ is defined inside that scope.
\item We cannot move it to the \verb+catch+ block because that means
  \verb+in+ will not be closed if no exceptions occur, which is even
  worse. 
\item Another possibility would be to declare \verb+in+ out of the
  \verb+try+ block and initialise it inside, then closing it
  outside. However, this risks a \verb+NullPointerException+ if it is
  never initialised (e.g.~because the file does not exist or is not
  readable). 
\item Finally, a fourth possibility is to duplicate the \verb+close()+
  call, which is clearly suboptimal.
\end{itemize}

We just need a way to make sure that a data source is always closed. 

This is what \verb+finally+ is for. Every \verb+try+ can have a
\verb+finally+ block that is always executed after the \verb+try+
block; if an exception was thrown and caught, the \verb+finally+
method will be executed after the code in the \verb+catch+ block is
executed. The code would look like this: 

\begin{verbatim}
01    File file = new File("file.csv");
02    try {
03        BufferedReader in = new BufferedReader(new FileReader(file); 
04        while ((String line = in.readLine) != null) {
05            // ... do things with the data here
06        }
07    } catch (IOException ex) {
08        ex.printStackTrace();
09    } catch (FileNotFoundException ex) {
10        System.out.println("File " + file + " does not exist.");
11    } finally { 
12        in.close()
13    }
\end{verbatim}







% Talk about finally
%
% and the new way of doing finally in Java 7
% 
% Exercises: 
%
% - ls
% - cd
% - mkdir 
% - cat
% - tr
% - uniq (*)
% - sort (*)

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "d16"
%%% End:
