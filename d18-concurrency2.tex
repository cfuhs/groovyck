\section{More concurrency}
\label{sec:more-concurrency}

Last unit we covered the basics of concurrent programming. We used the
low-level elements that we can use in Java to create program where
different tasks are being executed at the same time: threads and
locks (and in particular, the \verb+synchronized+ keyword). 

Although any kind of concurrent program can be created with these
elements, in reality they are too basic for big programs and/or
advanced tasks. It is very easy to make mistakes that will make a
program run slower or ---worse--- block completely by using threads
and locks directly. In the current context, in which multi-core
computers have become the norm and applications need to be able to
benefit from this inherent parallelism provided by the hardware,
higher-order structures are needed to create reliable concurrent
programs. 

Java 5 introduced several features that aimed at covering this
gap. The two most imporant, executors and concurrent collections, are
explained in the following sections.

% TODO: do fork/join

\section{Executors}
\label{sec:executors}

An \verb+Executor+ is an object that executes tasks. These tasks are
defined by other objects. 

This is similar to what we have been doing with threads. We have
created threads that ran tasks that were defined by a \verb+Runnable+
object, with a \verb+run()+ method. 

The problem with this approach is that the creation of the thread, its
lifetime, and the task it performs are closely linked. There is no
separation between thread and task, between container and
content. The thread lives for as long as the task is running, and as
soon as the task finished the thread dies. This has several
disadvantages: 

\begin{itemize}
\item Thread management is done manually and, therefore, is an
  error-prone process. The programmer must take care not only of the
  tasks that needs to be performed, but also of creating 
  the thread to run it, starting it, managing its interruptions, etc.
\item Thread creation takes time. In a highly concurrent application,
  creation and destruction (i.e. garbage collection) of threads can
  result in a performance penalty.
\item Thread are memory structures that use a non-trivial amount of
  memory. If threads are created manually one by one there is no
  way to measure the load of the application and to manage 
  it carefully to prevent running out of resources (not easily, at
  least). 
\end{itemize}

In a large-scale application, it makes sense to separate thread
creation and management from the rest of the application. Executors
are objects that encapsulate these operations hiding them from the
rest of the program. 

\subsection{Three types of executors}
\label{sec:three-types-exec}

Executors are defined by three interfaces in the
\verb+java.util.concurrent+ package; the package also provides some
implementation for these interfaces. 

\begin{description}
\item[Executor: ] This is the basic executor. It just supports
  launching new tasks.
\item[ExecutorService: ] This is an extension of the former one, and
  adds features that help manage the lifecyle of the tasks to be run
  and also the executor itself.
\item[ScheduledExecutorService: ] An extension of the former one, this
  interface adds methods to execute tasks in the future and at
  scheduled times. 
\end{description}

As usual, variables that represent executor objects should be declared
as one of these interfaces and not as one of the classes that
implement them.

\subsubsection{Executor}
\label{sec:executor}

The \verb+Executor+ interface defines only one method:
\verb+execute(...)+. This interface is rarely used compared to the
other two, but it was designed to be an easy replacement when fixing
legacy code that had been implemented using pure threads and locks. If
\verb+r+ is a \verb+Runnable+ object and \verb+e+ is an
\verb+Executor+ object, than we can replace: 

\begin{verbatim}
    Thread t = new Thread(r);
    t.start();
\end{verbatim}

with 

\begin{verbatim}
    e.execute(r);
\end{verbatim}

Simple, cleaner, and ---more important--- it opens the door to using
one of the other two more powerful executors. Additionally, depending
on the class that implements the \verb+Executor+, it may be able to
reuse threads from a thread pool or put the runnable tasks in a queue
if the system is busy; these things are not possible when using plain
threads. Thread pools and queues of tasks are two constructs that
are very convenient to ease the management of threads and solve some
of the problems of using plain threads as explained above. More on
that below. 

\subsubsection{Executor Services}
\label{sec:executor-services}

The \verb+ExecutorService+ interface extends the plain \verb+Executor+
with the \verb+submit(...)+ method, which is similar to
\verb+execute(...)+ but more versatile because it accepts both
\verb+Runnable+ and \verb+Callable+ tasks (i.e.~described by
objects). Callable objects are similar to runnable objects but they
can return a value when they finish their computation. 