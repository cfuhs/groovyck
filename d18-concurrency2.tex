\section{More concurrency}
\label{sec:more-concurrency}

Last unit we covered the basics of concurrent programming. We used the
low-level elements that we can use in Java to create program where
different tasks are being executed at the same time: threads and
locks (and in particular, the \verb+synchronized+ keyword). 

Although any kind of concurrent program can be created with these
elements, in reality they are too basic for big programs and/or
advanced tasks. It is very easy to make mistakes that will make a
program run slower or ---worse--- block completely by using threads
and locks directly. In the current context, in which multi-core
computers have become the norm and applications need to be able to
benefit from this inherent parallelism provided by the hardware,
higher-order structures are needed to create reliable concurrent
programs. 

Java 5 introduced several features that aimed at covering this
gap. The two most imporant, executors and concurrent collections, are
explained in the following sections.

% TODO: do fork/join

\section{Executors}
\label{sec:executors}

An \verb+Executor+ is an object that executes tasks. These tasks are
defined by other objects. 

This is similar to what we have been doing with threads. We have
created threads that ran tasks that were defined by a \verb+Runnable+
object, with a \verb+run()+ method. 

The problem with this approach is that the creation of the thread, its
lifetime, and the task it performs are closely linked. There is no
separation between thread and task, between container and
content. The thread lives for as long as the task is running, and as
soon as the task finished the thread dies. This has several
disadvantages: 

\begin{itemize}
\item Thread management is done manually and, therefore, is an
  error-prone process. The programmer must take care not only of the
  tasks that needs to be performed, but also of creating 
  the thread to run it, starting it, managing its interruptions, etc.
\item Thread creation takes time. In a highly concurrent application,
  creation and destruction (i.e. garbage collection) of threads can
  result in a performance penalty.
\item Thread are memory structures that use a non-trivial amount of
  memory. If threads are created manually one by one there is no
  way to measure the load of the application and to manage 
  it carefully to prevent running out of resources (not easily, at
  least). 
\end{itemize}

In a large-scale application, it makes sense to separate thread
creation and management from the rest of the application. Executors
are objects that encapsulate these operations hiding them from the
rest of the program. 

\subsection{Three types of executors}
\label{sec:three-types-exec}

Executors are defined by three interfaces in the java.util.concurrent
package. 